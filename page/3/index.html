<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"eviltuzki.top","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Eviltuzki">
<meta property="og:url" content="https://eviltuzki.top/page/3/index.html">
<meta property="og:site_name" content="Eviltuzki">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Eviltuzki">
<meta property="article:tag" content="Java,ElasticSearch,Go">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://eviltuzki.top/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Eviltuzki</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Eviltuzki</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">一线码农一枚</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>日程表</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://eviltuzki.top/2019/07/06/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%88%86%E6%9E%90-ThreadPoolExecutor/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Eviltuzki">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eviltuzki">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/07/06/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%88%86%E6%9E%90-ThreadPoolExecutor/" class="post-title-link" itemprop="url">Java线程池分析-ThreadPoolExecutor</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-07-06 00:00:00" itemprop="dateCreated datePublished" datetime="2019-07-06T00:00:00+08:00">2019-07-06</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="线程池状态"><a href="#线程池状态" class="headerlink" title="线程池状态"></a>线程池状态</h1><h2 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h2><ul>
<li>RUNNING<ul>
<li>该状态接受新的任务同时处理队列中的任务</li>
</ul>
</li>
<li>SHUTDOWN<ul>
<li>该状态不再接受新的任务，但是队列中的任务继续执行</li>
</ul>
</li>
<li>STOP<ul>
<li>不再接受新的任务，也不再处理队列中的任务，并且会中断正在运行的任务</li>
</ul>
</li>
<li>TIDYING<ul>
<li>所有任务都已经终止，工作线程数为0。调用terminated()方法状态会变为TIDYING</li>
</ul>
</li>
<li>TERMINATED<ul>
<li>terminated()方法执行完成</li>
</ul>
</li>
</ul>
<h2 id="状态转移"><a href="#状态转移" class="headerlink" title="状态转移"></a>状态转移</h2><ul>
<li>RUNNING -&gt; SHUTDOWN<ul>
<li>执行shutdown()方法（SHUTDOWN状态可能立即结束进入下一状态）</li>
</ul>
</li>
<li>(RUNNING or SHUTDOWN) -&gt; STOP<ul>
<li>执行shutdownNow()方法</li>
</ul>
</li>
<li>SHUTDOWN -&gt; TIDYING<ul>
<li>当所有任务队列和线程池(pool)都空的了时候</li>
</ul>
</li>
<li>STOP -&gt; TIDYING<ul>
<li>当线程池(pool)为空的时候</li>
</ul>
</li>
<li>TIDYING -&gt; TERMINATED<ul>
<li>terminated()方法完成<br>awaitTermination()在状态变为TERMINATED的时候返回</li>
</ul>
</li>
</ul>
<h2 id="状态位表示"><a href="#状态位表示" class="headerlink" title="状态位表示"></a>状态位表示</h2><p>状态位在线程池中使用一个原子类型的Integer进行存储</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));</span><br></pre></td></tr></table></figure>
<p>Integer的长度是32位，用全部32位来表示线程数量，有点浪费。线程池的状态一共就5种，所以大神决定用ctl的高3位（可以表示8种状态了），来表示线程池的状态，低29位用来计数（大约500_000_000），反正就目前机器来说，想同时开启这么多线程。。。机器早就挂了，所以足够了</p>
<h1 id="几个底层依赖的方法"><a href="#几个底层依赖的方法" class="headerlink" title="几个底层依赖的方法"></a>几个底层依赖的方法</h1><ul>
<li>private static int runStateOf(int c)     { return c &amp; ~CAPACITY; }<ul>
<li>通过位运算，获取当前线程池的状态</li>
</ul>
</li>
<li>private static int workerCountOf(int c)  { return c &amp; CAPACITY; }<ul>
<li>通过位运算，获取当前线程池的工作线程数</li>
</ul>
</li>
<li>private static int ctlOf(int rs, int wc) { return rs | wc; }<ul>
<li>为了看ctl的状态</li>
</ul>
</li>
<li>然后就是几个关于ctl的cas操作，包括增加一个线程计数，减少一个线程计数</li>
</ul>
<h1 id="几个重要的Field"><a href="#几个重要的Field" class="headerlink" title="几个重要的Field"></a>几个重要的Field</h1><ul>
<li>private final BlockingQueue<Runnable> workQueue;<ul>
<li>关键参数，设置线程池corePoolSize满了以后，要将任务放到什么样的阻塞队列中。</li>
</ul>
</li>
<li>private final ReentrantLock mainLock &#x3D; new ReentrantLock();<ul>
<li>内部锁，在很多方法中均有用到，包括添加Worker，中断Worker，shutdown，以及获取各种size都需要锁进行同步保护</li>
</ul>
</li>
<li>private final HashSet<Worker> workers &#x3D; new HashSet<Worker>();<ul>
<li>可以理解为线程的集合，Worker 继承了 AQS 并且实现了 Runnable，也就是线程池中对应的线程的集合。</li>
</ul>
</li>
<li>private final Condition termination &#x3D; mainLock.newCondition();<ul>
<li>在 tryTerminate() 方法中进行通知，awaitTermination(long timeout, TimeUnit unit)方法中进行awaitNanos，也就是说调用awaitTermination方法之后，会一直等待，直到tryTerminate方法执行并且通知，才会结束（这时候线程池应该就变为TERMINATED状态了）</li>
</ul>
</li>
<li>private int largestPoolSize;<ul>
<li>记录线程池中线程数量曾经达到过的最大值。</li>
</ul>
</li>
<li>private long completedTaskCount;<ul>
<li>这个从字面意思就很好立即了，已经完成的任务数量</li>
</ul>
</li>
<li>private volatile ThreadFactory threadFactory;<ul>
<li>又一个核心参数，线程的创建工厂，各种大厂的Java开发规范都需要业务自己实现对应的线程工厂，定义线程的名称之类的，主要是后期排查多线程问题的时候方便定位。</li>
</ul>
</li>
<li>private volatile RejectedExecutionHandler handler;<ul>
<li>也是核心参数，当线程池达到饱和状态（队列满了，maximumPoolSize也达到了），如果还在继续提交的任务，就依靠这个进行处理。</li>
<li>默认有4个实现类，如下：<ul>
<li>CallerRunsPolicy，这个就是将任务返回给调用方，由调用方执行。</li>
<li>AbortPolicy，这个比较粗暴，直接抛出异常。也是默认实现，参考defaultHandler</li>
<li>DiscardPolicy，这个应该很少用，直接丢弃提交的任务，Do Nothing</li>
<li>DiscardOldestPolicy，这个也是丢弃，不过是丢弃队列中最早的一个（直接调用peeK）</li>
</ul>
</li>
</ul>
</li>
<li>private volatile long keepAliveTime;<ul>
<li>核心参数之一，线程空闲多久后回收（默认如果小于corePoolSize，则不进行回收）</li>
</ul>
</li>
<li>private volatile boolean allowCoreThreadTimeOut;<ul>
<li>allowCoreThreadTimeOut，core线程是否超时后回收，默认是false</li>
</ul>
</li>
<li>private volatile int corePoolSize;<ul>
<li>核心参数，core线程池大小</li>
</ul>
</li>
<li>private volatile int maximumPoolSize;<ul>
<li>核心参数，最大线程池大小（超过这个值就会调用RejectedExecutionHandler）</li>
</ul>
</li>
<li>private static final RejectedExecutionHandler defaultHandler &#x3D; new AbortPolicy();<ul>
<li>默认Rejected处理策略，抛出异常</li>
</ul>
</li>
<li>private static final RuntimePermission shutdownPerm &#x3D; new RuntimePermission(“modifyThread”);<ul>
<li>这个真不太清楚，只知道是在调用shutdown相关方法会调用进行安全检查</li>
</ul>
</li>
<li>private final AccessControlContext acc;<ul>
<li>在finalize方法中有调用，看不太明白 &#x3D; &#x3D;，貌似也是权限访问层面的（AccessController.doPrivileged(pa, acc);）</li>
</ul>
</li>
</ul>
<h1 id="几个重要的-public-方法"><a href="#几个重要的-public-方法" class="headerlink" title="几个重要的 public 方法"></a>几个重要的 public 方法</h1><ul>
<li><p>public void execute(Runnable command)</p>
<ul>
<li>提交一个Runnable任务，描述很简单，实现应该是所有方法中最复杂的了，话不多说，直接上源码。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line">public void execute(Runnable command) &#123;</span><br><span class="line">    if (command == null)</span><br><span class="line">        throw new NullPointerException();//不允许提交null</span><br><span class="line">    int c = ctl.get();</span><br><span class="line">    //检查目前工作线程数量是否超过了corePoolSize，没有超过的话直接添加任务，添加成功就返回，添加失败则更新状态值c然后继续</span><br><span class="line">    if (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        if (addWorker(command, true))//参数为true则添加的是core线程</span><br><span class="line">            return;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    //执行到这里肯定是添加worker失败或者已经达到了corePoolSize</span><br><span class="line">    //这时候检查线程状态，确保是Running(因为有可能这期间其他线程调用了shutdown等方法)，就开始往队列中添加任务。</span><br><span class="line">    if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        int recheck = ctl.get();</span><br><span class="line">        //添加到队列之后，再次检查线程池状态，如果状态发生变化，则移除任务并执行拒绝策略</span><br><span class="line">        //如果状态没有发生改变，此时如果线程池为空，那就添加一个非核心Worker</span><br><span class="line">        if (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">        else if (workerCountOf(recheck) == 0)</span><br><span class="line">            addWorker(null, false);</span><br><span class="line">    &#125;//到这里说明添加队列失败，要么是线程池编程非RUNNING状态，要么队列满了，则添加非核心线程，非核心线程如果添加还是失败了，就只能执行拒绝策略了</span><br><span class="line">    else if (!addWorker(command, false))</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br><span class="line">//上面的步骤还不算复杂，接下就是最复杂的addWorker方法了。</span><br><span class="line">private boolean addWorker(Runnable firstTask, boolean core) &#123;</span><br><span class="line">    retry:   //标记位，用于循环控制，也就是外层循环</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        int c = ctl.get();</span><br><span class="line">        int rs = runStateOf(c);//当前线程池状态</span><br><span class="line">        //如果线程池状态如下，则返回添加失败</span><br><span class="line">        // 1. 线程池状态为STOP，TIDYING，TERMINATED中的一个</span><br><span class="line">        // 2. 线程池状态为SHUTDOWN，并且第一个任务不为空</span><br><span class="line">        // 3. 线程池状态为SHUTDOWN，并且工作队列为空</span><br><span class="line">        if (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">            ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">               firstTask == null &amp;&amp;</span><br><span class="line">               ! workQueue.isEmpty()))</span><br><span class="line">            return false;</span><br><span class="line">        //开始内层循环，执行到这里说明不是上述123中的状态。</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            int wc = workerCountOf(c);//获取工作线程数量</span><br><span class="line">            //检查是否达到上限，并根据添加的线程类别(core或者非core)判断是否超过对应的最大值，超过也返回false</span><br><span class="line">            if (wc &gt;= CAPACITY ||</span><br><span class="line">                wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                return false;</span><br><span class="line">            if (compareAndIncrementWorkerCount(c))//上述校验通过以后，CAS方式增加一个工作线程，如果成功了，则跳出外层循环</span><br><span class="line">                break retry;</span><br><span class="line">            //执行到这里说明cas方式增加线程失败，那就重新检查一下线程池状态，然后内层循环继续，直到增加成功。</span><br><span class="line">            c = ctl.get();  // Re-read ctl</span><br><span class="line">            if (runStateOf(c) != rs)</span><br><span class="line">                continue retry;</span><br><span class="line">            // else CAS failed due to workerCount change; retry inner loop</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //执行到这里，说明已经成功增加了一个线程计数了。</span><br><span class="line">    boolean workerStarted = false;</span><br><span class="line">    boolean workerAdded = false;</span><br><span class="line">    Worker w = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        w = new Worker(firstTask);//使用第一个任务创建一个Worker</span><br><span class="line">        final Thread t = w.thread;//获取对应worker的线程</span><br><span class="line">        if (t != null) &#123;</span><br><span class="line">            final ReentrantLock mainLock = this.mainLock;</span><br><span class="line">            mainLock.lock();</span><br><span class="line">            try &#123;</span><br><span class="line">                // Recheck while holding lock.</span><br><span class="line">                // Back out on ThreadFactory failure or if</span><br><span class="line">                // shut down before lock acquired.</span><br><span class="line">                int rs = runStateOf(ctl.get());//检查线程池的状态</span><br><span class="line">                //线程池状态是运行的或者刚刚关闭，第一个任务尚未赋值</span><br><span class="line">                if (rs &lt; SHUTDOWN ||</span><br><span class="line">                    (rs == SHUTDOWN &amp;&amp; firstTask == null)) &#123;</span><br><span class="line">                    //这里确保线程还没有被其他线程启动</span><br><span class="line">                    if (t.isAlive()) // precheck that t is startable</span><br><span class="line">                        throw new IllegalThreadStateException();</span><br><span class="line">                    //添加worker到workers集合中</span><br><span class="line">                    workers.add(w);</span><br><span class="line">                    int s = workers.size();</span><br><span class="line">                    //对比并更新最大到达数量</span><br><span class="line">                    if (s &gt; largestPoolSize)</span><br><span class="line">                        largestPoolSize = s;</span><br><span class="line">                    workerAdded = true;//表示已经增加了worker</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            //如果已经成功增加了worker，就可以启动对应的线程了。</span><br><span class="line">            if (workerAdded) &#123;</span><br><span class="line">                t.start();</span><br><span class="line">                workerStarted = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        //这里检查一下worker是否已经启动成功，如果没有启动成功，则执行添加失败操作</span><br><span class="line">        if (! workerStarted)</span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    &#125;</span><br><span class="line">    return workerStarted;//返回工作线程是否启动成功</span><br><span class="line">&#125;</span><br><span class="line">//简单看一下添加失败的逻辑</span><br><span class="line">private void addWorkerFailed(Worker w) &#123;</span><br><span class="line">    final ReentrantLock mainLock = this.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        if (w != null)</span><br><span class="line">            workers.remove(w);//添加失败则移除掉Set集合中对应的worker</span><br><span class="line">        //并且减少一个工作线程数量计数</span><br><span class="line">        decrementWorkerCount();</span><br><span class="line">        //尝试关闭线程池（感觉这里是为了释放空闲线程）</span><br><span class="line">        tryTerminate();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>public void shutdown() </p>
<ul>
<li>尝试关闭线程池，执行后状态变为SHUTDOWN，继续完成已经提交的任务，但是新的任务不再被接受。  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public void shutdown() &#123;</span><br><span class="line">    final ReentrantLock mainLock = this.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        checkShutdownAccess();//检查访问权？（这块有点懵）</span><br><span class="line">        advanceRunState(SHUTDOWN);//检查是否可以设置为SHUTDOWN并通过CAS操作设置为SHUTDOWN</span><br><span class="line">        interruptIdleWorkers();//中断线程</span><br><span class="line">        onShutdown(); // hook for ScheduledThreadPoolExecutor ，这里是空实现</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    tryTerminate();//检测并尝试终止线程池</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>几个内部调用的方法方法  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">    private void advanceRunState(int targetState) &#123;</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            int c = ctl.get();</span><br><span class="line">            //传参数为SHUTDOWN，则runStateAtLeast在SHUTDOWN、STOP、TIDYING和TERMINATED状态的时候为true，直接跳出循环。如果线程池状态为RUNNING，则进行CAS操作，更新状态位为SHUTDOWN，成功则结束。</span><br><span class="line">            if (runStateAtLeast(c, targetState) || ctl.compareAndSet(c, ctlOf(targetState, workerCountOf(c))))</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private void interruptIdleWorkers() &#123;</span><br><span class="line">        interruptIdleWorkers(false);//中断所有线程，如果参数为true，则仅中断一个线程，具体见下</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void interruptIdleWorkers(boolean onlyOne) &#123;</span><br><span class="line">        final ReentrantLock mainLock = this.mainLock;</span><br><span class="line">        mainLock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            for (Worker w : workers) &#123;</span><br><span class="line">                Thread t = w.thread;</span><br><span class="line">                //线程处于非中断状态，并且没有其他线程中断该线程（也就是说只能有一个线程进行中断操作）</span><br><span class="line">                if (!t.isInterrupted() &amp;&amp; w.tryLock()) &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        t.interrupt();//依次中断</span><br><span class="line">                    &#125; catch (SecurityException ignore) &#123;</span><br><span class="line">                    &#125; finally &#123;</span><br><span class="line">                        w.unlock();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                if (onlyOne)//如果为true，则中断一个后跳出循环</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //一个空实现</span><br><span class="line">    void onShutdown() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">final void tryTerminate() &#123;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        int c = ctl.get();</span><br><span class="line">        if (isRunning(c) ||//正在运行中，不能设置为TIDYING</span><br><span class="line">            runStateAtLeast(c, TIDYING) ||//线程池为TIDYING或者TERMINATED，其他线程已经开始关闭线程池</span><br><span class="line">            (runStateOf(c) == SHUTDOWN &amp;&amp; ! workQueue.isEmpty()))//队列中尚有需要执行的任务，需要等待执行完成，不能设置为TIDYING</span><br><span class="line">            return;</span><br><span class="line">        //上面一坨条件判断说白了就是在等线程池状态为SHUTDOWN并且队列为空或者线程池状态为STOP才会继续，否则放弃终止操作。</span><br><span class="line"></span><br><span class="line">        if (workerCountOf(c) != 0) &#123; // Eligible to terminate</span><br><span class="line">            interruptIdleWorkers(ONLY_ONE);//ONLY_ONE在这里为true，也就是仅仅中断一个空闲的worker。</span><br><span class="line">            //补充一下：interruptIdleWorkers的作用是因为在getTask方法中执行workQueue.take()时，如果不执行中断会一直阻塞。在shutdown方法中，会中断所有空闲的工作线程，如果在执行shutdown时工作线程没有空闲，然后又去调用了getTask方法，这时如果workQueue中没有任务了，调用workQueue.take()时就会一直阻塞。所以每次在工作线程结束时调用tryTerminate方法来尝试中断一个空闲工作线程，避免在队列为空时取任务一直阻塞的情况。(引用自：https://www.cnblogs.com/liuzhihu/p/8177371.html)</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        final ReentrantLock mainLock = this.mainLock;</span><br><span class="line">        mainLock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            if (ctl.compareAndSet(c, ctlOf(TIDYING, 0))) &#123;//CAS操作将线程池设置为TIDYING状态</span><br><span class="line">                try &#123;</span><br><span class="line">                    terminated();//执行一些清理操作</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    ctl.set(ctlOf(TERMINATED, 0));//设置线程池状态为TERMINATED</span><br><span class="line">                    termination.signalAll();//通知条件变量termination（也就是awaitTermination方法可以继续执行了）</span><br><span class="line">                &#125;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        // else retry on failed CAS</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>public List<Runnable> shutdownNow()</p>
<ul>
<li>立即关闭线程池，设置状态为STOP，不再接受新的任务，并且中断正在运行的任务，返回队列中未执行的任务。  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;Runnable&gt; shutdownNow() &#123;</span><br><span class="line">    List&lt;Runnable&gt; tasks;</span><br><span class="line">    final ReentrantLock mainLock = this.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        checkShutdownAccess();//检查访问权？（这块有点懵）</span><br><span class="line">        advanceRunState(STOP);//cas方式设置状态为STOP</span><br><span class="line">        interruptWorkers();//中断正在运行的线程</span><br><span class="line">        tasks = drainQueue();//将队列中未执行的任务返回</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    tryTerminate();//检测并尝试终止线程池</span><br><span class="line">    return tasks;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>看一下里面具体的方法，checkShutdownAccess、advanceRunState和tryTerminate见上  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">private void interruptWorkers() &#123;</span><br><span class="line">    final ReentrantLock mainLock = this.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        for (Worker w : workers)//遍历workers集合</span><br><span class="line">            w.interruptIfStarted();//依次中断</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Worker的interruptIfStarted方法如下：</span><br><span class="line">void interruptIfStarted() &#123;</span><br><span class="line">    Thread t;</span><br><span class="line">    //state小于0是不可中断的标识，只能在大于等于0的时候进行中断</span><br><span class="line">    if (getState() &gt;= 0 &amp;&amp; (t = thread) != null &amp;&amp; !t.isInterrupted()) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            t.interrupt();</span><br><span class="line">        &#125; catch (SecurityException ignore) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//转移队列剩余任务方法</span><br><span class="line">private List&lt;Runnable&gt; drainQueue() &#123;</span><br><span class="line">    BlockingQueue&lt;Runnable&gt; q = workQueue;</span><br><span class="line">    ArrayList&lt;Runnable&gt; taskList = new ArrayList&lt;Runnable&gt;();</span><br><span class="line">    q.drainTo(taskList);//将q的所有任务转移到taskList中</span><br><span class="line">    if (!q.isEmpty()) &#123;//上一步操作可能会失败，再次检查（什么情况会失败？这块我也没太明白）</span><br><span class="line">        for (Runnable r : q.toArray(new Runnable[0])) &#123;</span><br><span class="line">            if (q.remove(r))</span><br><span class="line">                taskList.add(r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return taskList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>public boolean isShutdown()</p>
<ul>
<li>通过ctl获取线程池的状态，没啥可说的</li>
</ul>
</li>
<li><p>public boolean isTerminating()</p>
<ul>
<li>通过ctl获取线程池的状态，只要不是运行的，不是TERMINATED，就处于这个状态</li>
</ul>
</li>
<li><p>public boolean isTerminated()</p>
<ul>
<li>通过ctl获取线程池的状态，并且状态是TERMINATED</li>
</ul>
</li>
<li><p>public boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException</p>
<ul>
<li>带超时的等待线程池状态变为TERMINATED  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public boolean awaitTermination(long timeout, TimeUnit unit)</span><br><span class="line">    throws InterruptedException &#123;</span><br><span class="line">    long nanos = unit.toNanos(timeout);</span><br><span class="line">    final ReentrantLock mainLock = this.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            if (runStateAtLeast(ctl.get(), TERMINATED))//CAS循环判断状态是否为TERMINATED</span><br><span class="line">                return true;</span><br><span class="line">            if (nanos &lt;= 0)//超时则返回false</span><br><span class="line">                return false;</span><br><span class="line">            nanos = termination.awaitNanos(nanos);//还记得上面的termination.signalAll()吧，就是这里等待通知</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>public boolean prestartCoreThread()</p>
<ul>
<li>调用该方法，则执行启动一个核心线程，源码比较简单，只要不足corePoolSize，就执行增加操作。  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public boolean prestartCoreThread() &#123;</span><br><span class="line">    return workerCountOf(ctl.get()) &lt; corePoolSize &amp;&amp;</span><br><span class="line">        addWorker(null, true);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>public int prestartAllCoreThreads()</p>
<ul>
<li>一次性启动Core工作线程到corePoolSize，返回启动了几个线程。  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public int prestartAllCoreThreads() &#123;</span><br><span class="line">    int n = 0;</span><br><span class="line">    while (addWorker(null, true))</span><br><span class="line">        ++n;</span><br><span class="line">    return n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>public boolean remove(Runnable task)</p>
<ul>
<li>移除一个task，移除操作之后会执行tryTerminate()方法  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public boolean remove(Runnable task) &#123;</span><br><span class="line">    boolean removed = workQueue.remove(task);</span><br><span class="line">    //会检查线程池状态，并根据状态决定是否终止线程池（特别针对的场景就是shudown状态+空队列，就可以进入下一个状态）</span><br><span class="line">    tryTerminate(); // In case SHUTDOWN and now empty</span><br><span class="line">    return removed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>public void purge() </p>
<ul>
<li>尝试从队列中移除所有已经取消了的Future任务  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public void purge() &#123;</span><br><span class="line">    final BlockingQueue&lt;Runnable&gt; q = workQueue;</span><br><span class="line">    try &#123;</span><br><span class="line">        Iterator&lt;Runnable&gt; it = q.iterator();</span><br><span class="line">        while (it.hasNext()) &#123;</span><br><span class="line">            Runnable r = it.next();</span><br><span class="line">            //移除掉已经取消的Future任务</span><br><span class="line">            if (r instanceof Future&lt;?&gt; &amp;&amp; ((Future&lt;?&gt;)r).isCancelled())</span><br><span class="line">                it.remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (ConcurrentModificationException fallThrough) &#123;//遍历过程中发生了其他修改，快速失败采用数组快照方式删除</span><br><span class="line">        // Take slow path if we encounter interference during traversal.</span><br><span class="line">        // Make copy for traversal and call remove for cancelled entries.</span><br><span class="line">        // The slow path is more likely to be O(N*N).</span><br><span class="line">        for (Object r : q.toArray())</span><br><span class="line">            if (r instanceof Future&lt;?&gt; &amp;&amp; ((Future&lt;?&gt;)r).isCancelled())</span><br><span class="line">                q.remove(r);</span><br><span class="line">    &#125;</span><br><span class="line">    //会检查线程池状态，并根据状态决定是否终止线程池（特别针对的场景就是shudown状态+空队列，就可以进入下一个状态）</span><br><span class="line">    tryTerminate(); // In case SHUTDOWN and now empty </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h1 id="待分析内容"><a href="#待分析内容" class="headerlink" title="待分析内容"></a>待分析内容</h1><h2 id="简单概述"><a href="#简单概述" class="headerlink" title="简单概述"></a>简单概述</h2><ul>
<li>上面这一堆只是简单分析了一下ThreadPoolExecutor内部的方法，这个类继承了AbstractExecutorService，之后会在分析一下AbstractExecutorService，此外ThreadPoolExecutor内部还有一个Worker类，它承了AbstractQueuedSynchronizer(AQS)，这两个也是后面要分析的重点。尤其是AQS，后面的各种锁相关都是依赖于它</li>
</ul>
<h2 id="TODO项"><a href="#TODO项" class="headerlink" title="TODO项"></a>TODO项</h2><ul>
<li>AbstractExecutorService</li>
<li>Worker</li>
<li>AbstractQueuedSynchronizer</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://eviltuzki.top/2019/07/02/Cow%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Eviltuzki">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eviltuzki">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/07/02/Cow%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">CopyOnWriteArrayList && CopyOnWriteArraySet 总结</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-07-02 00:00:00" itemprop="dateCreated datePublished" datetime="2019-07-02T00:00:00+08:00">2019-07-02</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>这两个都是Java提供的原生写时复制的容器(也就是java.util.concurrent包下的)。CopyOnWrite的基本思路是在修改(包括增加和修改)之前，拷贝出一份快照，对快照进行修改，然后替换原引用。读取操作则没有进行加锁，所以适用于读多写少的场景。另外由于使用了快照模式(迭代器，修改等操作)，因此不能保证强一致性，只能保证最终一致性。</p>
<p>CopyOnWriteArraySet是对CopyOnWriteArrayList的包装，所以重点关注一下CopyOnWriteArrayList。</p>
<h1 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h1><p>从增删改查4个方面总结下这个容器（相对ConcurrentHashMap，CopyOnWrite的实现实在是简单太多了。。。）</p>
<h2 id="增"><a href="#增" class="headerlink" title="增"></a>增</h2><p>增加方法就2个：</p>
<ul>
<li>public boolean add(E e)<ul>
<li>整体思路比较简单，先获取排他锁（同一时刻只能有一个线程进行修改操作），然后拷贝一份新的数组并插入新的元素（此时读取操作读的还是旧的数组），最后替换引用并释放锁。  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public boolean add(E e) &#123;</span><br><span class="line">    final ReentrantLock lock = this.lock;</span><br><span class="line">    lock.lock();//获取排他锁</span><br><span class="line">    try &#123;</span><br><span class="line">        Object[] elements = getArray();//获取当前引用（可以理解为快照）</span><br><span class="line">        int len = elements.length;//当前的长度</span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + 1);//拷贝到一个新的数组中</span><br><span class="line">        newElements[len] = e;//末尾增加新的元素</span><br><span class="line">        setArray(newElements);//替换引用</span><br><span class="line">        return true;//返回结果</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();//释放排他锁</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>public void add(int index, E element)<ul>
<li>整体流程和上一个方法基本一致，区别在于进行索引的有效判断，同时检测是不是在数组的最后插入，拷贝的过程是调用System.arraycopy进行分区间拷贝。  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public void add(int index, E element) &#123;</span><br><span class="line">    final ReentrantLock lock = this.lock;</span><br><span class="line">    lock.lock();//一样获取独占锁</span><br><span class="line">    try &#123;</span><br><span class="line">        Object[] elements = getArray();//获取当前引用</span><br><span class="line">        int len = elements.length;</span><br><span class="line">        if (index &gt; len || index &lt; 0)//越界检查</span><br><span class="line">            throw new IndexOutOfBoundsException(&quot;Index: &quot;+index+</span><br><span class="line">                                                &quot;, Size: &quot;+len);</span><br><span class="line">        Object[] newElements;</span><br><span class="line">        int numMoved = len - index;</span><br><span class="line">        if (numMoved == 0)//判断是不是最后一个元素</span><br><span class="line">            newElements = Arrays.copyOf(elements, len + 1);//直接同上一个方法，生成len+1长度的数组</span><br><span class="line">        else &#123;</span><br><span class="line">            newElements = new Object[len + 1];//生成新的空数组</span><br><span class="line">            System.arraycopy(elements, 0, newElements, 0, index);//拷贝0~index</span><br><span class="line">            System.arraycopy(elements, index, newElements, index + 1,</span><br><span class="line">                            numMoved);//拷贝index+1 ~ 最后</span><br><span class="line">        &#125;</span><br><span class="line">        newElements[index] = element;//index位置填充</span><br><span class="line">        setArray(newElements);//替换引用</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();//释放锁</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="删"><a href="#删" class="headerlink" title="删"></a>删</h2><p>删除操作对外暴露了2个方法，一个是通过索引下标进行删除，一个是找到指定的Object进行删除。</p>
<ul>
<li>public E remove(int index)<ul>
<li>这个方法实现和 add(int index, E element) 基本类似，不做过多解释了。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public E remove(int index) &#123;</span><br><span class="line">    final ReentrantLock lock = this.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        int len = elements.length;</span><br><span class="line">        E oldValue = get(elements, index);//获取指定下标元素</span><br><span class="line">        int numMoved = len - index - 1;</span><br><span class="line">        if (numMoved == 0)//判断是否为最后一个元素</span><br><span class="line">            setArray(Arrays.copyOf(elements, len - 1));//形成新的0~len-1数组</span><br><span class="line">        else &#123;</span><br><span class="line">            Object[] newElements = new Object[len - 1];</span><br><span class="line">            //跳过要删除的元素                                 </span><br><span class="line">            System.arraycopy(elements, 0, newElements, 0, index);</span><br><span class="line">            System.arraycopy(elements, index + 1, newElements, index,</span><br><span class="line">                             numMoved);</span><br><span class="line">            setArray(newElements);//替换引用</span><br><span class="line">        &#125;</span><br><span class="line">        return oldValue;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>public boolean remove(Object o)<ul>
<li>首先获取数组引用，然后尝试寻找元素，找到了则进入删除操作，找不到则直接返回false  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public boolean remove(Object o) &#123;</span><br><span class="line">    Object[] snapshot = getArray();//获取引用快照</span><br><span class="line">    int index = indexOf(o, snapshot, 0, snapshot.length);//尝试寻找（注意，此时并未加锁，如果此时插入了数据或者其他线程插入了数据，是看不到的,需要在删除的时候重新进行查找）</span><br><span class="line">    return (index &lt; 0) ? false : remove(o, snapshot, index);//找到了则进行删除(index&gt;=0的情况)，找不到则返回false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>看一下具体的删除操作  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">private boolean remove(Object o, Object[] snapshot, int index) &#123;</span><br><span class="line">        final ReentrantLock lock = this.lock;</span><br><span class="line">        lock.lock();//加锁</span><br><span class="line">        try &#123;</span><br><span class="line">            Object[] current = getArray();//重新获取一次快照引用</span><br><span class="line">            int len = current.length;</span><br><span class="line">            if (snapshot != current) findIndex: &#123;//判断在上一步中获取到的快照是否发生了改变，如果没有改变，则直接进行删除，如果发生了改变，则需要进一步处理，也就是下面的逻辑。</span><br><span class="line">                int prefix = Math.min(index, len);//判断一下以防数组越界</span><br><span class="line">                for (int i = 0; i &lt; prefix; i++) &#123;</span><br><span class="line">                    if (current[i] != snapshot[i] &amp;&amp; eq(o, current[i])) &#123;//依次遍历查找，找到则结束if语句块，并更新index</span><br><span class="line">                        index = i;</span><br><span class="line">                        break findIndex;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                if (index &gt;= len)//上述条件并未找到，则判断是否已经超过索引长度(其他线程已经删除元素了，可能会执行到这里)</span><br><span class="line">                    return false;</span><br><span class="line">                if (current[index] == o)//这块没想明白什么情况会执行到这里</span><br><span class="line">                    break findIndex;</span><br><span class="line">                index = indexOf(o, current, index, len);//重新查找，因为已经加锁了，所以不会有其他线程进行修改</span><br><span class="line">                if (index &lt; 0)</span><br><span class="line">                    return false;//没有找到</span><br><span class="line">            &#125;</span><br><span class="line">            //后面就简单了，还是重新拷贝，更新引用</span><br><span class="line">            Object[] newElements = new Object[len - 1];</span><br><span class="line">            System.arraycopy(current, 0, newElements, 0, index);</span><br><span class="line">            System.arraycopy(current, index + 1,</span><br><span class="line">                            newElements, index,</span><br><span class="line">                            len - index - 1);</span><br><span class="line">            setArray(newElements);</span><br><span class="line">            return true;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="改"><a href="#改" class="headerlink" title="改"></a>改</h2><p>修改操作相对比较简单，通过索引下标直接更新即可，方法如下：</p>
<ul>
<li>public E set(int index, E element)<ul>
<li>操作也不复杂，加锁后重新拷贝并替换，唯独注意就是元素没有变化，也要重新更新一下引用（注释说是为了确保volatile写语义）  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public E set(int index, E element) &#123;</span><br><span class="line">        final ReentrantLock lock = this.lock;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            Object[] elements = getArray();</span><br><span class="line">            E oldValue = get(elements, index);</span><br><span class="line"></span><br><span class="line">            if (oldValue != element) &#123;</span><br><span class="line">                int len = elements.length;</span><br><span class="line">                Object[] newElements = Arrays.copyOf(elements, len);</span><br><span class="line">                newElements[index] = element;</span><br><span class="line">                setArray(newElements);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // Not quite a no-op; ensures volatile write semantics</span><br><span class="line">                setArray(elements);</span><br><span class="line">            &#125;</span><br><span class="line">            return oldValue;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="查"><a href="#查" class="headerlink" title="查"></a>查</h2><p>查询操作外部暴露了4个方法,其实内部都是委托给对应的私有方法，只是没有index参数的方法委托的时候传值是0。</p>
<ul>
<li>public int indexOf(Object o)</li>
<li>public int indexOf(E e, int index)</li>
<li>public int lastIndexOf(Object o)</li>
<li>public int lastIndexOf(E e, int index)<br>前两个方法委托给 private static int indexOf(Object o, Object[] elements, int index, int fence) 执行<br>后两个方法委托给 private static int lastIndexOf(Object o, Object[] elements, int index) 执行<br>下面整理一下这两个查找方法：</li>
<li>indexOf 只是看一下元素是否为空，为空则找null，不为空则直接进行遍历查找  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">private static int indexOf(Object o, Object[] elements,</span><br><span class="line">                        int index, int fence) &#123;</span><br><span class="line">    if (o == null) &#123;</span><br><span class="line">        for (int i = index; i &lt; fence; i++)</span><br><span class="line">            if (elements[i] == null)</span><br><span class="line">                return i;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        for (int i = index; i &lt; fence; i++)</span><br><span class="line">            if (o.equals(elements[i]))</span><br><span class="line">                return i;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>lastIndexOf 和 indexOf 几乎相同，只是倒着查找而已。  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private static int lastIndexOf(Object o, Object[] elements, int index) &#123;</span><br><span class="line">        if (o == null) &#123;</span><br><span class="line">            for (int i = index; i &gt;= 0; i--)</span><br><span class="line">                if (elements[i] == null)</span><br><span class="line">                    return i;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            for (int i = index; i &gt;= 0; i--)</span><br><span class="line">                if (o.equals(elements[i]))</span><br><span class="line">                    return i;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h2><ul>
<li><p>contains方法，也是直接调用indexOf方法，判断一下索引位置是不是&gt;&#x3D;0,就不多说了</p>
</li>
<li><p>get方法，直接获取一下数组引用(获取引用之后，其他线程修改，这里也看不到了。。。)，然后取对应下标。</p>
</li>
<li><p>addIfAbsent方法，CopyOnWriteArraySet就是基于这个方法实现的。先通过indexOf方法查找，找到直接返回false，找不到则加锁进行添加，添加之前会判断一下引用是否改变，和remove比较相似。代码如下：</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">private boolean addIfAbsent(E e, Object[] snapshot) &#123;</span><br><span class="line">        final ReentrantLock lock = this.lock;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            Object[] current = getArray();</span><br><span class="line">            int len = current.length;</span><br><span class="line">            if (snapshot != current) &#123;//引用发生改变，则需要重新查找，如果还是没找到，则继续添加</span><br><span class="line">                // Optimize for lost race to another addXXX operation</span><br><span class="line">                int common = Math.min(snapshot.length, len);</span><br><span class="line">                for (int i = 0; i &lt; common; i++)//遍历查找，并且找到了，则返回false</span><br><span class="line">                    if (current[i] != snapshot[i] &amp;&amp; eq(e, current[i]))</span><br><span class="line">                        return false;</span><br><span class="line">                if (indexOf(e, current, common, len) &gt;= 0)//没太明白为什么又要再次查找。。</span><br><span class="line">                        return false;</span><br><span class="line">            &#125;</span><br><span class="line">            Object[] newElements = Arrays.copyOf(current, len + 1);</span><br><span class="line">            newElements[len] = e;</span><br><span class="line">            setArray(newElements);</span><br><span class="line">            return true;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>containsAll方法, 实现也比较简单暴力，获取快照后，直接for循环对每一个元素进行判断，就不附代码了。</p>
</li>
<li><p>removeAll方法，也不算复杂，加锁之后遍历元素，不在待删除集合中，则加入新数组中，然后重新拷贝一份即可</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public boolean removeAll(Collection&lt;?&gt; c) &#123;</span><br><span class="line">        if (c == null) throw new NullPointerException();</span><br><span class="line">        final ReentrantLock lock = this.lock;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            Object[] elements = getArray();</span><br><span class="line">            int len = elements.length;</span><br><span class="line">            if (len != 0) &#123;</span><br><span class="line">                // temp array holds those elements we know we want to keep</span><br><span class="line">                int newlen = 0;</span><br><span class="line">                Object[] temp = new Object[len];</span><br><span class="line">                for (int i = 0; i &lt; len; ++i) &#123;</span><br><span class="line">                    Object element = elements[i];</span><br><span class="line">                    if (!c.contains(element))</span><br><span class="line">                        temp[newlen++] = element;</span><br><span class="line">                &#125;</span><br><span class="line">                if (newlen != len) &#123;</span><br><span class="line">                    setArray(Arrays.copyOf(temp, newlen));</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return false;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>retainAll方法，和removeAll方法类似，对应的是两个集合都包含的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public boolean retainAll(Collection&lt;?&gt; c) &#123;</span><br><span class="line">        if (c == null) throw new NullPointerException();</span><br><span class="line">        final ReentrantLock lock = this.lock;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            Object[] elements = getArray();</span><br><span class="line">            int len = elements.length;</span><br><span class="line">            if (len != 0) &#123;</span><br><span class="line">                // temp array holds those elements we know we want to keep</span><br><span class="line">                int newlen = 0;</span><br><span class="line">                Object[] temp = new Object[len];</span><br><span class="line">                for (int i = 0; i &lt; len; ++i) &#123;</span><br><span class="line">                    Object element = elements[i];</span><br><span class="line">                    if (c.contains(element))</span><br><span class="line">                        temp[newlen++] = element;</span><br><span class="line">                &#125;</span><br><span class="line">                if (newlen != len) &#123;</span><br><span class="line">                    setArray(Arrays.copyOf(temp, newlen));</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return false;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>addAllAbsent方法, indexOf(e, cs, 0, added) 采用将遍历过的待添加元素数组进行替换，节省了新开辟数组的空间，这是一个用的很巧的方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public int addAllAbsent(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">    Object[] cs = c.toArray();</span><br><span class="line">    if (cs.length == 0)</span><br><span class="line">        return 0;</span><br><span class="line">    final ReentrantLock lock = this.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        int len = elements.length;</span><br><span class="line">        int added = 0;</span><br><span class="line">        // uniquify and compact elements in cs</span><br><span class="line">        for (int i = 0; i &lt; cs.length; ++i) &#123;</span><br><span class="line">            Object e = cs[i];</span><br><span class="line">            if (indexOf(e, elements, 0, len) &lt; 0 &amp;&amp;</span><br><span class="line">                indexOf(e, cs, 0, added) &lt; 0)</span><br><span class="line">                cs[added++] = e;</span><br><span class="line">        &#125;</span><br><span class="line">        if (added &gt; 0) &#123;</span><br><span class="line">            Object[] newElements = Arrays.copyOf(elements, len + added);</span><br><span class="line">            System.arraycopy(cs, 0, newElements, len, added);</span><br><span class="line">            setArray(newElements);</span><br><span class="line">        &#125;</span><br><span class="line">        return added;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>clear方法，就是设置一个空数组，就不附代码了</p>
</li>
<li><p>addAll方法，也比较简单，转成数组之后直接合并，带索引位置的，就是跳过一部分后，在插入，最后补充剩余的</p>
</li>
<li><p>sort方法，也比较简单，拷贝一份快照后，对快照进行排序，然后替换引用。</p>
</li>
<li><p>equals 和 hashCode ，这两个方法都进行了重写，注意一下，都是使用快照进行比较，所以都是弱一致性的。</p>
</li>
<li><p>iterator 迭代器是创建一个COWIterator迭代器，不支持删除和修改操作，只能进行读取操作。</p>
</li>
<li><p>其他就不进行分析了</p>
</li>
</ul>
<h1 id="CopyOnWriteArraySet"><a href="#CopyOnWriteArraySet" class="headerlink" title="CopyOnWriteArraySet"></a>CopyOnWriteArraySet</h1><p>其实没啥可分析的，内部就一个CopyOnWriteArrayList，所有方法都是调用 CopyOnWriteArrayList的方法，去重用的是addIfAbsent和addAllAbsent方法，&#x3D; &#x3D;感觉这个Set性能有点差。。。远不及HashSet和TreeSet。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>平时项目中时不时还是会用到CopyOnWriteArrayList，CopyOnWriteArraySet至少我还没用到过，而且看了实现，也不太敢用。。。。<br>回归主题：</p>
<ul>
<li>CopyOnWrite相关读取操作都是不加锁的，拷贝一份内部数组的引用，就开始读取了，不用加锁的原因就是所有的数组实际上都不会发生改变，因为所有的修改操作都是生成一份新的数组。</li>
<li>因为读取或者迭代器，乃至hashcode，equals方法都是基于快照进行相关操作，所以可能读到的数据并不是最新的，也就是无法保证实时的一致性(就是所谓的弱一致性)，但是最终数据还是一致的。</li>
<li>因为几乎每次修改，都会生成新的数组，如果写入比较频繁，可能产生大量垃圾，加重GC负担，所以CopyOnWrite最适合的场景就是读多写少。</li>
<li>CopyOnWriteArrayList源码上有很多值得学习的小技巧，比如addAllAbsent方法中用替换数组中读过的位置存储待合并字符，省去了开辟新数组的开销。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://eviltuzki.top/2019/06/30/Java%E9%9B%86%E5%90%88%E7%B1%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Eviltuzki">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eviltuzki">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/06/30/Java%E9%9B%86%E5%90%88%E7%B1%BB/" class="post-title-link" itemprop="url">Java 集合类整理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-06-30 00:00:00" itemprop="dateCreated datePublished" datetime="2019-06-30T00:00:00+08:00">2019-06-30</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h1><p>好像Java面试必不可少的一个问题就是，Java中集合有哪些？分别有什么特点。照搬各种《XXX从入门到放弃》，集合有2种类型，一个是有序可重复的List，一个是无序不可重复的Set，可是真的用起来的时候好像就不是简单的这样了。  </p>
<p>先来看一下集合的整体关系图(并发包中的集合没有考虑进来，仅看java.util包)<br><img src="/Java%E9%9B%86%E5%90%88%E7%B1%BB/Collection.png" alt="Java集合类">  </p>
<p>第一眼看上去我也懵，本来以为自己天天用的那些集合类已经差不多了，然后发现一坨坨的没见过没用过的。</p>
<h1 id="那就啃吧。。"><a href="#那就啃吧。。" class="headerlink" title="那就啃吧。。"></a>那就啃吧。。</h1><h2 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h2><ul>
<li>Collection应该是老大哥级别的了，算是集合类的鼻祖（迭代器忽略），定义了一个集合应该有的基本方法，包括增删迭代等，这个就不多说了。</li>
<li>1.8版本开始，增加了流式操作的几个default方法(先不关注了)</li>
</ul>
<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>List应该是集合中用的最多最多的了，平时搬砖，基本上几行代码就要加上一个List存储各种元素。忽略抽象方法，整理一下对应的实现类</p>
<h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><p>ArrayList应该是日常搬砖使用最多的的实现了，特点如下:</p>
<ul>
<li>底层实现是数组，对应代码:<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transient Object[] elementData;</span><br></pre></td></tr></table></figure></li>
<li>实现了动态扩容方法，简单说就是容量不够了，我就新建一个数组，然后将原来的数据拷贝到新数组中。从代码int newCapacity &#x3D; oldCapacity + (oldCapacity &gt;&gt; 1);中也可以看出来，每次扩容变为原本的1.5倍。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private void grow(int minCapacity) &#123;</span><br><span class="line">    // overflow-conscious code</span><br><span class="line">    int oldCapacity = elementData.length;</span><br><span class="line">    int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);</span><br><span class="line">    if (newCapacity - minCapacity &lt; 0)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    // minCapacity is usually close to size, so this is a win:</span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>线程不安全，所有方法没有加锁，多线程存在并发问题</li>
<li>因为底层实现是数组，所以随机读取速度很快，并不是说不适合插入数据，而是不适合在中间或者头部插入数据。因为插入数据之后，当前位置后面的元素都要往后移动，成本相对来说比较大了。代码如下:<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.arraycopy(elementData, index, elementData, index + 1, size - index);</span><br><span class="line">elementData[index] = element;</span><br></pre></td></tr></table></figure></li>
<li>删除操作也是同理，在末尾操作其实影响不大，但是在中间和数组起始位置操作成本就有点高了。</li>
<li>更新操作影响很小，直接找到对应数组下标，然后替换就可以了。</li>
<li>indexOf和contains以及lastIndexOf方法都是直接进行遍历，因为数组是无序的，也没办法采用二分法之类的进行快速查找。所以尽可能不要直接使用List的查找方法。</li>
<li>size方法成本不高，并不是每次都进行统计，而是内部存储了一个size变量，每次增删操作回进行更新。</li>
<li>暂时想到的就这么多，以后想起来再补充。</li>
</ul>
<h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h3><p>这个可是个老古董了，从JDK1.0开始就存在了（别问我怎么知道的，那会我也没用过Java，是文档自己写的。。。。），正因为是老古董，所以现在已经不是很推荐使用了，原因就是效率很低下，因为很多方法都暴力的增加了synchronized关键字，性能很低下。做个简单总结吧：</p>
<ul>
<li>因为很多方法都加上了synchronized关键词，导致整体性能较差，不推荐使用</li>
<li>底层实现也是数组，特性和ArrayList差不多。</li>
<li>注意：Vector没有实现Serializable接口</li>
<li>关于扩容：ArrayList每次扩容是1.5倍，Vector是2倍。代码如下：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private void grow(int minCapacity) &#123;</span><br><span class="line">    // overflow-conscious code</span><br><span class="line">    int oldCapacity = elementData.length;</span><br><span class="line">    int newCapacity = oldCapacity + ((capacityIncrement &gt; 0) ?</span><br><span class="line">                                     capacityIncrement : oldCapacity);//扩充一倍</span><br><span class="line">    if (newCapacity - minCapacity &lt; 0)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
capacityIncrement是构造方法传进来的，如果不指定，则传0。</li>
</ul>
<h3 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h3><p>这个类已经快被遗忘了，简单概述一下。</p>
<ul>
<li>1.0时代的远古产物，继承了Vector，所以也是各种synchronized关键字，性能低下</li>
<li>官方注释已经不推荐使用了，同样的功能可以使用Deque实现<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;Integer&gt; stack = new ArrayDeque&lt;Integer&gt;();</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><p>你以为LinkedList仅仅是一个链表实现的List的么？？那你就是图样图森破了，来看看强大的LinkedList吧。</p>
<ul>
<li>看一下接口层面：List、deque和Queue，也就是说LinkedList不仅仅是一个list集合，同时也是一个双向队列，当然也可以作为单向队列来使用。所以根据场景，上面的Stack也可以使用LinkedList进行替换</li>
<li>底层的实现是基于链表，基本存储数据的元素是Node，代码如下：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private static class Node&lt;E&gt; &#123;</span><br><span class="line">        E item;</span><br><span class="line">        Node&lt;E&gt; next;</span><br><span class="line">        Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">        Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">            this.item = element;</span><br><span class="line">            this.next = next;</span><br><span class="line">            this.prev = prev;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li>正是因为基于链表实现，所以理论上在任意位置进行增删操作都是O(1)的时间复杂度，但是为什么我说是理论上呢？因为实际进行增删的时候，必须要先找到对应的位置吧？这个查找的过程时间复杂度可就是O(n)了。</li>
<li>LinkedList同样没有加任何同步措施，因此也是线程不安全的。</li>
<li>说一个坑点：千万不要在for循环中通过索引的方式去获取元素（之前实习生干了这个事。。。），因为链表的<strong>通过索引方式进行随机读取的时间复杂度是O(n)</strong>!</li>
</ul>
<h3 id="简单汇总一下"><a href="#简单汇总一下" class="headerlink" title="简单汇总一下"></a>简单汇总一下</h3><table>
<thead>
<tr>
<th>列</th>
<th>ArrayList</th>
<th>LinkedList</th>
<th>Vector</th>
<th>Stack</th>
</tr>
</thead>
<tbody><tr>
<td>实现方式</td>
<td>数组</td>
<td>链表</td>
<td>数组</td>
<td>数组</td>
</tr>
<tr>
<td>线程安全</td>
<td>否</td>
<td>否</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>优势</td>
<td>适合随机读，末尾写</td>
<td>适合随机写，顺序读</td>
<td>线程安全</td>
<td>线程安全</td>
</tr>
<tr>
<td>劣势</td>
<td>不适合随机写入</td>
<td>不适合随机读取</td>
<td>性能差</td>
<td>性能差</td>
</tr>
<tr>
<td>扩容</td>
<td>1.5</td>
<td>-</td>
<td>2</td>
<td>-</td>
</tr>
</tbody></table>
<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>上面简单总结了一下List相关实现，接下来看看狐假虎威的Set。为啥说Set是狐假虎威呢？看看对应的实现类就明白了，基本上都是Map套了个壳（Map稍后总结）</p>
<h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><p>基于Hash实现的Set，内层实现是HashMap，所有的操作都是HashMap的Key的操作，而Map的实际Value则是一个Object对象。总结一下特点：</p>
<ul>
<li>判断是否存在速度很快，基于Hash实现如果不出现冲突，基本都是O(1)的操作。</li>
<li>线程不安全，需要自己实现线程同步方式</li>
<li>元素唯一（前提重写HashCode和equals方法,只有两者都相同才被认为是同一个元素）</li>
<li>不保证顺序，因为基于Hash实现，无法保证读取时候的顺序(也就是通过迭代器方式读取无法保证顺序，不过貌似重写HashCode之后，可以在一定程度上控制顺序，但是最好不要这么用。。)</li>
<li>因为底层实现是HashSet，所以也存在初始容量和负载因子，因此使用的时候如果事先知道存储大小，最好指定一下大小和负载因子，减少扩容消耗。</li>
<li>因为HashSet支持null作为key，所以HashSet也可以存储null元素</li>
</ul>
<h3 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h3><p>LinkedHashSet也是一个壳，继承了HashSet，注意一下HashSet内部还有一个带有boolean的构造方法，调用这种构造方法，则内部实现不再是HashMap，而是LinkedHashMap。</p>
<ul>
<li>LinkedHashSet和HashSet最大的区别就是能保证元素插入的顺序和通过迭代器读取的顺序是一致的(但是不是经过排序的，是保留插入的顺序)。</li>
<li>除了有序这个之外，其他特点和HashSet一样，因为继承了嘛(写这个类的人，真的是懒到极致的。。向他学习！)</li>
</ul>
<h3 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h3><p>看到TreeSet是不是立即想到了TreeMap？对的，TreeSet内部就是一个NavigableMap，NavigableMap又是什么？java.util包下原生的实现且暴露出来的好像只有。。。。TreeMap。。。</p>
<ul>
<li>内部实现是TreeMap，也就是基于红黑树（啥是红黑树？。。。自行百度。。）,所以整体操作复杂度事O(log(n)),表面上看不如HashSet的O(1)速度快，但是一旦出现大量Hash冲突的时候，HashSet性能将急剧下降，因为冲突导致查询变为链表遍历(好像1.8还是1.7开始，冲突元素个数增加到8就会进行树化，防止链表过长)，而TreeSet不会存在这个问题。</li>
<li>TreeSet实现了NavigableSet接口和SortedSet接口，也就是说TreeSet中的元素是有序的，同时是支持范围查询,查找大于或者小于某个元素的元素或者集合(具体看NavigableSet接口)，这些都是HashSet无法提供的。</li>
<li>线程不安全，补充：因为红黑树实现复杂，并发粒度控制困难(应该是这个原因)，官方没有提供TreeSet对应的并发类，而是提供了基于跳表实现的并发类(后面再说)</li>
<li>其他想到了再补充。。</li>
</ul>
<h3 id="EnumSet"><a href="#EnumSet" class="headerlink" title="EnumSet"></a>EnumSet</h3><p>EnumSet是一个抽象类，有两个实现：</p>
<ul>
<li>RegularEnumSet</li>
<li>JumboEnumSet</li>
</ul>
<p>注意一下，这两个类都是不对外暴露的，对外统一暴露的是EnumSet。这两个类有啥区别呢？RegularEnumSet存储的是元素个数小于等于64个，JumboEnumSet则是超过64个。<br>为啥要单独出来一个EnumSet呢？HashSet，TreeSet也是可以存储枚举的啊，查了一堆资料(实际上我也没用过这玩意。。)，总结如下：</p>
<ul>
<li>EnumSet的速度很快，原因是底层用了elements进行位运算，也就是说EnumSet并不直接存放枚举对象，而是存储一个对应类和elements，通过位运算来判断Set中有哪些元素，速度自然要快得多。</li>
<li>一旦元素的枚举类型确定那么集合就确定了（因为要通过枚举类型进行位判断，如果更换了枚举类型，会导致结果出错，所以不允许修改）</li>
<li>EnumSet只能存放一种枚举类型的元素(原因同上)</li>
</ul>
<h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h2><p>一个先入先出的数据结构，util包下实现好像只有下面3个，这个主要在juc包下实现类较多(各种阻塞队列)</p>
<h3 id="LinkedList-1"><a href="#LinkedList-1" class="headerlink" title="LinkedList"></a>LinkedList</h3><p>前面已经说过，不再多说了。</p>
<h3 id="ArrayDeque"><a href="#ArrayDeque" class="headerlink" title="ArrayDeque"></a>ArrayDeque</h3><p>和LinkedList相比，最大不同就是底层实现是依赖于一个数组,简单汇总一下其特点:</p>
<ul>
<li>实现依赖于一个循环数组</li>
<li>扩容: 扩容直接将容量翻倍，然后执行数组拷贝</li>
<li>容量：要求必须是2的幂次方(方便进行位移运算)</li>
<li>优势：和LinkedList相比，无需用Node对数据进行包裹，而且数组通过下标访问速度很快</li>
<li>应用场景:额。。。其实我也没怎么用过，感觉常用栈和队列都可以用这个实现(好吧，以前我都是用LinkedList实现栈的操作。。。)</li>
</ul>
<h3 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h3><p>这个感觉平时用的也很少，是一个带有优先级的队列(并发包中的优先队列貌似使用场景更多一些。。)，这个研究不多，直接当个搬运工吧(参考:<a target="_blank" rel="noopener" href="https://www.cnblogs.com/mfrank/p/9614520.html">https://www.cnblogs.com/mfrank/p/9614520.html</a>)</p>
<ul>
<li>内部是根据小顶堆的结构进行存储的</li>
<li>构造方法需要传入一个比较器，用于判断优先级</li>
<li>内部实际上也是使用一个数组进行数据存储，同时有一个heapify()方法，用于将数组进行堆化(具体过程就不描述了。。。)</li>
<li>应用场景，基本上就是堆的应用场景，比如寻找topN之类的</li>
</ul>
<h1 id="顺便肯一下另外一组容器"><a href="#顺便肯一下另外一组容器" class="headerlink" title="顺便肯一下另外一组容器"></a>顺便肯一下另外一组容器</h1><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>Map我的理解就是存储键值对的容器，基本上每一种开发语言都有这种容器，比如Python,C#的字典，golang的map，应该说Map是和数组一个级别的重要容器了。最常用的应该是基于Hash实现的HashMap，当然还有基于红黑树的TreeMap。先看一下Map相关的类图：<br><img src="/Java%E9%9B%86%E5%90%88%E7%B1%BB/Map.png" alt="Java集合类"><br>简单总结一下：</p>
<h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p>最常用的Map，没有之一(至少我工作这两年看到的Map，九成以上都是HashMap)，应该也是面试必问容器，后面估计要专门整理一篇HashMap的总结了(网上各种总结已经一大把了。。)，简单总结一下特点：</p>
<ul>
<li>基于hash的方法，能够快速通过key找到对应的value</li>
<li>内部存储数据是基于数组，Node&lt;K,V&gt;[] table;</li>
<li>线程不安全(几乎面试都会问到，然后就自然转到了juc的并发包了)</li>
<li>Key建议使用字符串，当然用自定义对象也可以，但是要重写hashcode和equals方法，否则不保证正确性了。</li>
<li>hash冲突的解决是通过链表方式，链表长度超过8以后，转为红黑树，当长度减少到6一下，再次转换为链表。(原因是怕链表长度过长，导致查询速度过慢，而冲突变少之后使用链表和树速度差别小，但是复杂度来看，链表要简单。。好吧，也是强行解释)</li>
<li>迭代遍历不保证顺序</li>
<li>允许null作为key和value</li>
</ul>
<h3 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a>Hashtable</h3><p>远古产物，并且类命名还不对，正确命名应该是HashTable，估计是当时开发人员粗心，写成了Hashtable，然后为了兼容性，那就错着把。。。功能上和HashMap基本一样，简单总结一下:</p>
<ul>
<li>线程安全，但是性能低下，全部基于synchronized关键词实现。</li>
<li>不允许null作为key和value</li>
</ul>
<h3 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h3><ul>
<li>与HashMap相比，保留的key的插入顺序性，遍历的时候和插入的顺序一致</li>
<li>原理是内部维护了一条双向链表，记录插入的顺序</li>
<li>额外增加了空间和时间上的开销</li>
<li>应用场景<ul>
<li>保留插入顺序的遍历场景</li>
<li>LRU缓存的实现(可以看一下MyBatis的缓存实现，其中就有基于LinkedHashMap的LRU缓存)</li>
</ul>
</li>
</ul>
<h3 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h3><p>这个因为红黑树实现，有点复杂(面试在单独复习红黑树吧。。)，所以就不管内部具体实现了，总结一下特点</p>
<ul>
<li>线程不安全，即使是在并发包中也没有TreeMap的并发类</li>
<li>实现了SortedMap接口，说明Key是有序的</li>
<li>遍历的时候根据Key的自然顺序进行，或者指定Comparator比较器</li>
<li>实现了NavigableMap接口，也就是说支持区间范围或者比大小操作(基于Key的)</li>
<li>整体操作复杂度均为O(log(n))</li>
</ul>
<h3 id="EnumMap"><a href="#EnumMap" class="headerlink" title="EnumMap"></a>EnumMap</h3><p>针对枚举类作为Key的情形进行优化的Map，内部通过数组存储，查找的时候直接通过枚举的ordinal作为index快速查询。</p>
<ul>
<li>只能支持单一类型枚举</li>
</ul>
<h3 id="IdentityHashMap"><a href="#IdentityHashMap" class="headerlink" title="IdentityHashMap"></a>IdentityHashMap</h3><p>陌生么？陌生。。。陌生就对了，因为日常开发中，压根就不会用到这玩意。。这玩意干嘛用的，它实际上是严格版本的HashMap，有多严格？引用必须相等！  </p>
<p>HashMap中判断key相等的依据是key.equals(otherKey),而IdentityHashMap判断key相等的依据是key&#x3D;&#x3D;otherKey，这种严格的限制，恕我无知。。我实在是找不到应用场景。。关键这个类还是大神Doug Lea写的。。。大神的思维。。不懂。。不懂。。</p>
<h3 id="WeakHashMap"><a href="#WeakHashMap" class="headerlink" title="WeakHashMap"></a>WeakHashMap</h3><p>这个容器使用之前最好先了解一下Java中的引用(强软弱虚)，WeakHashMap是一种弱key实现的容器，使用场景主要还是缓存吧(反正我没用过。。。)，说一下特点</p>
<ul>
<li>当key被GC回收后，对应Map中的KeyValue対也会被回收，附代码示例:<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">    WeakHashMap&lt;String, Object&gt; map = new WeakHashMap&lt;&gt;();</span><br><span class="line">    String k1 = new String(&quot;k1&quot;); //注意一定要使用new String(&quot;xxx&quot;)，形式</span><br><span class="line">    String k2 = new String(&quot;k2&quot;);</span><br><span class="line">    String k3 = new String(&quot;k3&quot;);</span><br><span class="line">    map.put(k1,new Object());</span><br><span class="line">    map.put(k2,new Object());</span><br><span class="line">    map.put(k3,new Object());</span><br><span class="line">    System.out.println(map);</span><br><span class="line">    System.gc();</span><br><span class="line">    Thread.sleep(500);</span><br><span class="line">    System.out.println(map);</span><br><span class="line">    k1 = null;</span><br><span class="line">    k2 = null;</span><br><span class="line">    k3 = null;</span><br><span class="line">    System.out.println(&quot;Key=null -&gt; &quot; +map);</span><br><span class="line">    System.gc();</span><br><span class="line">    Thread.sleep(500);</span><br><span class="line">    System.out.println(&quot;After GC -&gt; &quot; +map);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h3><p>以前我还真不知道Properties竟然也是Map的实现类，内部主要是各种读取配置文件相关逻辑，存储方面由于继承了Hashtable，所以也是线程安全的，关于这个就不分析啥了。。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>糊里糊涂整理了一下java.util包下面的集合相关类(容器类也行。。)，发现了几个平时开发中没用过的容器，但是其实是都可以用的。。。比如ArrayDeque，比如Enum相关Set和Map(恕我无知，之前真的都是通过HashSet和HashMap实现的。。。)。等后续有时间了，整理一下并发包下面的容器（好像已经烂大街了。。。）</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://eviltuzki.top/2019/06/23/CompletableFuture%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Eviltuzki">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eviltuzki">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/06/23/CompletableFuture%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB/" class="post-title-link" itemprop="url">CompletableFuture 学习汇总</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-06-23 00:00:00" itemprop="dateCreated datePublished" datetime="2019-06-23T00:00:00+08:00">2019-06-23</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="static方法"><a href="#static方法" class="headerlink" title="static方法"></a>static方法</h3><h4 id="public-static-CompletableFuture-supplyAsync-Supplier-supplier"><a href="#public-static-CompletableFuture-supplyAsync-Supplier-supplier" class="headerlink" title="public static  CompletableFuture supplyAsync(Supplier supplier)"></a>public static <U> CompletableFuture<U> supplyAsync(Supplier<U> supplier)</h4><ul>
<li>提交一个Supplier任务，异步执行，可以获取任务返回结果，使用ForkJoinPool.commonPool()执行任务。</li>
</ul>
<h4 id="public-static-CompletableFuture-supplyAsync-Supplier-supplier-Executor-executor"><a href="#public-static-CompletableFuture-supplyAsync-Supplier-supplier-Executor-executor" class="headerlink" title="public static  CompletableFuture supplyAsync(Supplier supplier, Executor executor)"></a>public static <U> CompletableFuture<U> supplyAsync(Supplier<U> supplier, Executor executor)</h4><ul>
<li>提交一个Supplier任务，异步执行，可以获取任务返回结果，使用指定的线程池执行</li>
</ul>
<h4 id="public-static-CompletableFuture-runAsync-Runnable-runnable"><a href="#public-static-CompletableFuture-runAsync-Runnable-runnable" class="headerlink" title="public static CompletableFuture runAsync(Runnable runnable)"></a>public static CompletableFuture<Void> runAsync(Runnable runnable)</h4><ul>
<li>提交一个Runnable任务，异步执行，无返回结果，使用ForkJoinPool.commonPool()执行任务。</li>
</ul>
<h4 id="public-static-CompletableFuture-runAsync-Runnable-runnable-Executor-executor"><a href="#public-static-CompletableFuture-runAsync-Runnable-runnable-Executor-executor" class="headerlink" title="public static CompletableFuture runAsync(Runnable runnable, Executor executor)"></a>public static CompletableFuture<Void> runAsync(Runnable runnable, Executor executor)</h4><ul>
<li>提交一个Supplier任务，异步执行，无返回结果，使用指定的线程池执行</li>
</ul>
<h4 id="public-static-CompletableFuture-completedFuture-U-value"><a href="#public-static-CompletableFuture-completedFuture-U-value" class="headerlink" title="public static  CompletableFuture completedFuture(U value)"></a>public static <U> CompletableFuture<U> completedFuture(U value)</h4><ul>
<li>新建一个完成的CompletableFuture，通常作为计算的起点阶段。</li>
</ul>
<h4 id="public-static-CompletableFuture-allOf-CompletableFuture-lt-gt-…-cfs"><a href="#public-static-CompletableFuture-allOf-CompletableFuture-lt-gt-…-cfs" class="headerlink" title="public static CompletableFuture allOf(CompletableFuture&lt;?&gt;… cfs)"></a>public static CompletableFuture<Void> allOf(CompletableFuture&lt;?&gt;… cfs)</h4><ul>
<li>接收一个由CompletableFuture 构成的数组，需要等待多个 CompletableFuture 对象执行完毕，执行join操作可以等待CompletableFuture执行完成。</li>
</ul>
<h4 id="public-static-CompletableFuture-anyOf-CompletableFuture-lt-gt-…-cfs"><a href="#public-static-CompletableFuture-anyOf-CompletableFuture-lt-gt-…-cfs" class="headerlink" title="public static CompletableFuture anyOf(CompletableFuture&lt;?&gt;… cfs)"></a>public static CompletableFuture<Object> anyOf(CompletableFuture&lt;?&gt;… cfs)</h4><ul>
<li>接收一个由CompletableFuture 构成的数组，返回由第一个执行完毕的 CompletableFuture 对象的返回值构成的CompletableFuture<Object> 。</li>
</ul>
<h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">import java.text.SimpleDateFormat;</span><br><span class="line">import java.util.Date;</span><br><span class="line">import java.util.concurrent.CompletableFuture;</span><br><span class="line">import java.util.concurrent.ExecutionException;</span><br><span class="line">import java.util.concurrent.ExecutorService;</span><br><span class="line">import java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line">public class ThreadTest1 &#123;</span><br><span class="line">    private static SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss.SSS&quot;);</span><br><span class="line">    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;</span><br><span class="line">        ExecutorService pool = Executors.newFixedThreadPool(4);</span><br><span class="line">        //创建一个直接完成的CompletableFuture</span><br><span class="line">        String now = CompletableFuture.completedFuture(&quot;Test&quot;)</span><br><span class="line">                .getNow(&quot;Fail&quot;);</span><br><span class="line">        println(&quot;completedFuture: &quot; + now);</span><br><span class="line">        //创建一个带有返回值的CompletableFuture</span><br><span class="line">        CompletableFuture&lt;String&gt; task = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            sleep(100);</span><br><span class="line">            return &quot;Test&quot;;</span><br><span class="line">        &#125;, pool);</span><br><span class="line">        //延迟100ms，这里获取是default值</span><br><span class="line">        now = task.getNow(&quot;Fail&quot;);</span><br><span class="line">        println(&quot;supplyAsync: now: &quot; + now);</span><br><span class="line">        //等待任务完成后输出</span><br><span class="line">        println(&quot;supplyAsync: get: &quot; + task.get());</span><br><span class="line">        System.out.println(&quot;---------------------分割线----------------------&quot;);</span><br><span class="line">        //耗时100ms的任务</span><br><span class="line">        CompletableFuture&lt;Void&gt; task100 = CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">            sleep(100);</span><br><span class="line">            println(&quot;runAsync :&quot; + Thread.currentThread().getName() + &quot; task100 done&quot;);</span><br><span class="line">        &#125;, pool);</span><br><span class="line">        //耗时200ms的任务</span><br><span class="line">        CompletableFuture&lt;Void&gt; task200 = CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">            sleep(200);</span><br><span class="line">            println(&quot;runAsync :&quot; + Thread.currentThread().getName() + &quot; task200 done&quot;);</span><br><span class="line">        &#125;, pool);</span><br><span class="line">        //任意一个完成就会继续执行</span><br><span class="line">        CompletableFuture.anyOf(task100, task200).join();</span><br><span class="line">        println(&quot;anyOf Done&quot;);</span><br><span class="line">        //全部完成才会继续执行</span><br><span class="line">        CompletableFuture.allOf(task100, task200).join();</span><br><span class="line">        println(&quot;allOf Done&quot;);</span><br><span class="line">        //关闭线程池</span><br><span class="line">        pool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void sleep(long time) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(time);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    private static void println(Object object)&#123;</span><br><span class="line">        System.out.println(sdf.format(new Date()) + &quot;: &quot; + object);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">2019-06-23 18:02:03.552: completedFuture: Test</span><br><span class="line">2019-06-23 18:02:03.604: supplyAsync: now: Fail</span><br><span class="line">2019-06-23 18:02:03.710: supplyAsync: get: Test</span><br><span class="line">-------------------------------------------</span><br><span class="line">2019-06-23 18:02:03.813: runAsync :pool-1-thread-2 task100 done</span><br><span class="line">2019-06-23 18:02:03.813: anyOf Done</span><br><span class="line">2019-06-23 18:02:04.012: runAsync :pool-1-thread-3 task200 done</span><br><span class="line">2019-06-23 18:02:04.012: allOf Done</span><br></pre></td></tr></table></figure>

<h3 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h3><ul>
<li>实例方法整体比较规则，一个标准执行方法，一个异步执行方法，一个指定异步线程执行方法</li>
</ul>
<h4 id="thenApply"><a href="#thenApply" class="headerlink" title="thenApply"></a>thenApply</h4><ul>
<li>then是指在当前阶段正常执行完成后（正常执行是指没有抛出异常）进行的操作。Apply是指将一个Function作用于之前阶段得出的结果(即将上一步的结果进行转换)</li>
<li>public <U> CompletableFuture<U> (Function&lt;? super T,? extends U&gt; fn)</li>
<li>public <U> CompletableFuture<U> thenApplyAsync(Function&lt;? super T,? extends U&gt; fn)</li>
<li>public <U> CompletableFuture<U> thenApplyAsync(Function&lt;? super T,? extends U&gt; fn, Executor executor) <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static void thenApplyAsyncDemo()&#123;</span><br><span class="line">    Integer integer = CompletableFuture</span><br><span class="line">            .completedFuture(&quot;task 1&quot;)</span><br><span class="line">            .thenApplyAsync(x -&gt; &#123;</span><br><span class="line">                String intString = x.split(&quot; &quot;)[1];</span><br><span class="line">                return Integer.valueOf(intString);</span><br><span class="line">            &#125;)</span><br><span class="line">            .join();</span><br><span class="line">    System.out.println(&quot;thenApplyAsyncDemo: &quot; + integer);</span><br><span class="line">&#125;</span><br><span class="line">--------- 输出 -----------</span><br><span class="line">thenApplyAsyncDemo: 1    </span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="thenAccept"><a href="#thenAccept" class="headerlink" title="thenAccept"></a>thenAccept</h4><ul>
<li>下一个Stage接收了当前Stage的结果但是在计算中无需返回值(可以简单认为这里就是消费终点，因为没有返回值。当然下一步不依赖当前返回值的情况除外)</li>
<li>public CompletableFuture<Void> thenAccept(Consumer&lt;? super T&gt; action)</li>
<li>public CompletableFuture<Void> thenAcceptAsync(Consumer&lt;? super T&gt; action)</li>
<li>public CompletableFuture<Void> thenAcceptAsync(Consumer&lt;? super T&gt; action,Executor executor)<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static void thenAcceptDemo()&#123;</span><br><span class="line">    CompletableFuture</span><br><span class="line">            .completedFuture(&quot;task&quot;)</span><br><span class="line">            .thenAcceptAsync(s -&gt; &#123;</span><br><span class="line">                System.out.println(&quot;thenAcceptDemo：&quot; + s);</span><br><span class="line">            &#125;)</span><br><span class="line">            .join();</span><br><span class="line">&#125;</span><br><span class="line">--------- 输出 -----------</span><br><span class="line">thenAcceptDemo：task</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="thenRun"><a href="#thenRun" class="headerlink" title="thenRun"></a>thenRun</h4><ul>
<li>不再关心上一步运算的结果，直接进行下一步的运算</li>
<li>public CompletableFuture<Void> thenRun(Runnable action)</li>
<li>public CompletableFuture<Void> thenRunAsync(Runnable action)</li>
<li>public CompletableFuture<Void> thenRunAsync(Runnable action, Executor executor)<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void thenRunDemo() &#123;</span><br><span class="line">    CompletableFuture.completedFuture(&quot;Task&quot;)</span><br><span class="line">            .thenRun(() -&gt; System.out.println(&quot;我不知道上面的参数，也不会继续往下传递值&quot;))</span><br><span class="line">            .join();</span><br><span class="line">&#125;</span><br><span class="line">--------- 输出 -----------</span><br><span class="line">我不知道上面的参数，也不会继续往下传递值</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="thenCombine"><a href="#thenCombine" class="headerlink" title="thenCombine"></a>thenCombine</h4><ul>
<li>结合前面两个Stage的结果，进行转化</li>
<li>public &lt;U,V&gt; CompletableFuture<V> thenCombine(CompletionStage&lt;? extends U&gt; other, BiFunction&lt;? super T,? super U,? extends V&gt; fn)</li>
<li>public &lt;U,V&gt; CompletableFuture<V> thenCombineAsync(CompletionStage&lt;? extends U&gt; other,BiFunction&lt;? super T,? super U,? extends V&gt; fn) </li>
<li>public &lt;U,V&gt; CompletableFuture<V> thenCombineAsync(CompletionStage&lt;? extends U&gt; other,BiFunction&lt;? super T,? super U,? extends V&gt; fn, Executor executor)<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static void thenCombineDemo() &#123;</span><br><span class="line">    CompletableFuture&lt;String&gt; task1 = CompletableFuture.supplyAsync(() -&gt; &quot;task 1&quot;);</span><br><span class="line">    CompletableFuture&lt;String&gt; task2 = CompletableFuture.supplyAsync(() -&gt; &quot;task 2&quot;);</span><br><span class="line">    String result = task1.thenCombineAsync(task2, (t1, t2) -&gt; t1 + &quot; - &quot;+ t2)</span><br><span class="line">            .join();</span><br><span class="line">    System.out.println(result);</span><br><span class="line">&#125;</span><br><span class="line">--------- 输出 -----------</span><br><span class="line">task 1 - task 2</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="thenAcceptBoth"><a href="#thenAcceptBoth" class="headerlink" title="thenAcceptBoth"></a>thenAcceptBoth</h4><ul>
<li>结合两个CompletionStage的结果，进行消耗,和thenCombine相比，只是少了返回值</li>
<li>public <U> CompletableFuture<Void> thenAcceptBoth(CompletionStage&lt;? extends U&gt; other,BiConsumer&lt;? super T, ? super U&gt; action)</li>
<li>public <U> CompletableFuture<Void> thenAcceptBothAsync(CompletionStage&lt;? extends U&gt; other,BiConsumer&lt;? super T, ? super U&gt; action) </li>
<li>public <U> CompletableFuture<Void> thenAcceptBothAsync(CompletionStage&lt;? extends U&gt; other,BiConsumer&lt;? super T, ? super U&gt; action, Executor executor) <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static void thenAcceptBothDemo() &#123;</span><br><span class="line">    CompletableFuture&lt;String&gt; task1 = CompletableFuture.supplyAsync(() -&gt; &quot;task 1&quot;);</span><br><span class="line">    CompletableFuture&lt;String&gt; task2 = CompletableFuture.supplyAsync(() -&gt; &quot;task 2&quot;);</span><br><span class="line">    task1.thenAcceptBoth(task2, (t1, t2) -&gt; System.out.println(&quot;thenAcceptBothDemo: &quot; +t1 + &quot; - &quot; + t2))</span><br><span class="line">            .join();</span><br><span class="line">&#125;</span><br><span class="line">--------- 输出 -----------</span><br><span class="line">thenAcceptBothDemo: task 1 - task 2</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="runAfterBoth"><a href="#runAfterBoth" class="headerlink" title="runAfterBoth"></a>runAfterBoth</h4><ul>
<li>在两个CompletionStage都运行完执行。</li>
<li>public CompletableFuture<Void> runAfterBoth(CompletionStage&lt;?&gt; other,Runnable action)</li>
<li>public CompletableFuture<Void> runAfterBothAsync(CompletionStage&lt;?&gt; other,Runnable action) </li>
<li>public CompletableFuture<Void> runAfterBothAsync(CompletionStage&lt;?&gt; other,Runnable action,Executor executor) <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public static void runAfterBothDemo() &#123;</span><br><span class="line">    CompletableFuture&lt;Void&gt; task1 = CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">        sleep(100);</span><br><span class="line">        println(&quot;task1 Done&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    CompletableFuture&lt;Void&gt; task2 = CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">        sleep(200);</span><br><span class="line">        println(&quot;task2 Done&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    task1.runAfterBoth(task2, () -&gt; println(&quot;Task 1 And Task 2 Both Done&quot;))</span><br><span class="line">            .join();</span><br><span class="line">&#125;</span><br><span class="line">--------- 输出 -----------</span><br><span class="line">2019-06-23 19:22:08.498: task1 Done</span><br><span class="line">2019-06-23 19:22:08.595: task2 Done</span><br><span class="line">2019-06-23 19:22:08.596: Task 1 And Task 2 Both Done</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="applyToEither"><a href="#applyToEither" class="headerlink" title="applyToEither"></a>applyToEither</h4><ul>
<li>在两个CompletionStage中选择计算快的，将其结果进行下一步的转化操作。</li>
<li>public <U> CompletableFuture<U> applyToEither(CompletionStage&lt;? extends T&gt; other, Function&lt;? super T, U&gt; fn)</li>
<li>public <U> CompletableFuture<U> applyToEitherAsync(CompletionStage&lt;? extends T&gt; other, Function&lt;? super T, U&gt; fn) </li>
<li>public <U> CompletableFuture<U> applyToEitherAsync(CompletionStage&lt;? extends T&gt; other, Function&lt;? super T, U&gt; fn,Executor executor) <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static void applyToEitherDemo() &#123;</span><br><span class="line">    CompletableFuture&lt;String&gt; task1 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        sleep(10);</span><br><span class="line">        return &quot;task 1&quot;;</span><br><span class="line">    &#125;);</span><br><span class="line">    CompletableFuture&lt;String&gt; task2 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        sleep(20);</span><br><span class="line">        return &quot;task 2&quot;;</span><br><span class="line">    &#125;);</span><br><span class="line">    Integer result = task1.applyToEither(task2, t -&gt; Integer.valueOf(t.split(&quot; &quot;)[1]))</span><br><span class="line">            .join();</span><br><span class="line">    System.out.println(&quot;applyToEitherDemo:&quot; + result);</span><br><span class="line">&#125;</span><br><span class="line">--------- 输出 -----------</span><br><span class="line">applyToEitherDemo:1</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="acceptEither"><a href="#acceptEither" class="headerlink" title="acceptEither"></a>acceptEither</h4><ul>
<li>在两个CompletionStage中选择计算快的，作为下一步计算的结果。</li>
<li>public CompletableFuture<Void> acceptEither(CompletionStage&lt;? extends T&gt; other, Consumer&lt;? super T&gt; action) </li>
<li>public CompletableFuture<Void> acceptEitherAsync(CompletionStage&lt;? extends T&gt; other, Consumer&lt;? super T&gt; action)</li>
<li>public CompletableFuture<Void> acceptEitherAsync(CompletionStage&lt;? extends T&gt; other, Consumer&lt;? super T&gt; action,Executor executor)<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public static void acceptEitherDemo() &#123;</span><br><span class="line">    CompletableFuture&lt;String&gt; task1 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        sleep(10);</span><br><span class="line">        return &quot;task 1&quot;;</span><br><span class="line">    &#125;);</span><br><span class="line">    CompletableFuture&lt;String&gt; task2 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        sleep(20);</span><br><span class="line">        return &quot;task 2&quot;;</span><br><span class="line">    &#125;);</span><br><span class="line">    task1.acceptEitherAsync(task2, t -&gt; System.out.println(&quot;acceptEitherDemo:&quot; +Integer.valueOf(t.split(&quot; &quot;)[1])))</span><br><span class="line">            .join();</span><br><span class="line">&#125;</span><br><span class="line">--------- 输出 -----------</span><br><span class="line">acceptEitherDemo:1</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="runAfterEither"><a href="#runAfterEither" class="headerlink" title="runAfterEither"></a>runAfterEither</h4><ul>
<li>两个CompletionStage，任何一个完成了都会执行下一步的操作。</li>
<li>public CompletableFuture<Void> runAfterEither(CompletionStage&lt;?&gt; other,Runnable action) </li>
<li>public CompletableFuture<Void> runAfterEitherAsync(CompletionStage&lt;?&gt; other,Runnable action) </li>
<li>public CompletableFuture<Void> runAfterEitherAsync(CompletionStage&lt;?&gt; other,Runnable action,Executor executor) <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public static void runAfterEitherDemo() &#123;</span><br><span class="line">    CompletableFuture&lt;Void&gt; task1 = CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">        sleep(100);</span><br><span class="line">        println(&quot;task1 Done&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    CompletableFuture&lt;Void&gt; task2 = CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">        sleep(200);</span><br><span class="line">        println(&quot;task2 Done&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    task1.runAfterEither(task2, () -&gt; println(&quot;Task 1 Or Task 2 Done&quot;))</span><br><span class="line">            .join();</span><br><span class="line">    sleep(100);</span><br><span class="line">&#125;</span><br><span class="line">--------- 输出 -----------</span><br><span class="line">2019-06-23 19:24:27.644: task1 Done</span><br><span class="line">2019-06-23 19:24:27.645: Task 1 Or Task 2 Done</span><br><span class="line">2019-06-23 19:24:27.749: task2 Done</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="thenCompose"><a href="#thenCompose" class="headerlink" title="thenCompose"></a>thenCompose</h4><ul>
<li>连接两个CompletableFuture，返回值是新的CompletableFuture</li>
<li>public <U> CompletableFuture<U> thenCompose(Function&lt;? super T, ? extends CompletionStage<U>&gt; fn) </li>
<li>public <U> CompletableFuture<U> thenComposeAsync(Function&lt;? super T, ? extends CompletionStage<U>&gt; fn) </li>
<li>public <U> CompletableFuture<U> thenComposeAsync(Function&lt;? super T, ? extends CompletionStage<U>&gt; fn,Executor executor)<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static void thenComposeDemo() &#123;</span><br><span class="line">    String result = CompletableFuture.completedFuture(&quot;Start&quot;)</span><br><span class="line">            .thenCompose(x -&gt; CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">                sleep(20);</span><br><span class="line">                return x + &quot; task 2&quot;;</span><br><span class="line">            &#125;))</span><br><span class="line">            .thenCompose(x -&gt; CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">                sleep(10);</span><br><span class="line">                return x + &quot; task 1&quot;;</span><br><span class="line">            &#125;))</span><br><span class="line">            .join();</span><br><span class="line">    System.out.println(&quot;thenComposeDemo:&quot; +result);</span><br><span class="line">&#125;</span><br><span class="line">--------- 输出 -----------</span><br><span class="line">thenComposeDemo:Start task 2 task 1</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="whenComplete"><a href="#whenComplete" class="headerlink" title="whenComplete"></a>whenComplete</h4><ul>
<li>当运行完成时，对结果的记录。<ul>
<li>正常执行，返回值。</li>
<li>异常抛出造成程序的中断</li>
</ul>
</li>
<li>注意，内部线程出现异常会抛到外层，导致外层线程产生异常。</li>
<li>public CompletableFuture<T> whenComplete(BiConsumer&lt;? super T, ? super Throwable&gt; action) </li>
<li>public CompletableFuture<T> whenCompleteAsync(BiConsumer&lt;? super T, ? super Throwable&gt; action)</li>
<li>public CompletableFuture<T> whenCompleteAsync(BiConsumer&lt;? super T, ? super Throwable&gt; action, Executor executor) <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public static void whenCompleteDemo() &#123;</span><br><span class="line">    CompletableFuture&lt;String&gt; task1 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        sleep(10);</span><br><span class="line">        return &quot;task 1&quot;;</span><br><span class="line">    &#125;);</span><br><span class="line">    CompletableFuture&lt;String&gt; task2 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        sleep(20);</span><br><span class="line">        throw new RuntimeException(&quot;task2 RuntimeException&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    String task1res = task1.whenComplete((res, exp) -&gt; &#123;</span><br><span class="line">        println(&quot;task1 res:&quot; + res);</span><br><span class="line">        println(&quot;task1 exp:&quot; + exp);</span><br><span class="line">    &#125;).join();</span><br><span class="line">    println(task1res);</span><br><span class="line">    String task2res = task2.whenComplete((res, exp) -&gt; &#123;</span><br><span class="line">        println(&quot;task2 res:&quot; + res);</span><br><span class="line">        println(&quot;task2 exp:&quot; + exp.getMessage());</span><br><span class="line">    &#125;).join();</span><br><span class="line">    println(task2res);</span><br><span class="line">&#125;</span><br><span class="line">--------- 输出 -----------</span><br><span class="line">2019-06-23 19:50:03.429 ForkJoinPool.commonPool-worker-1: task1 res:task 1</span><br><span class="line">2019-06-23 19:50:03.430 ForkJoinPool.commonPool-worker-1: task1 exp:null</span><br><span class="line">2019-06-23 19:50:03.430 main: task 1</span><br><span class="line">2019-06-23 19:50:03.439 ForkJoinPool.commonPool-worker-2: task2 res:null</span><br><span class="line">2019-06-23 19:50:03.439 ForkJoinPool.commonPool-worker-2: task2 exp:java.lang.RuntimeException: task2 RuntimeException</span><br><span class="line">Exception in thread &quot;main&quot; java.util.concurrent.CompletionException: java.lang.RuntimeException: task2 RuntimeException</span><br><span class="line">    at java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:273)</span><br><span class="line">    at java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:280)</span><br><span class="line">    at java.util.concurrent.CompletableFuture$AsyncSupply.run(CompletableFuture.java:1592)</span><br><span class="line">    at java.util.concurrent.CompletableFuture$AsyncSupply.exec(CompletableFuture.java:1582)</span><br><span class="line">    at java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:289)</span><br><span class="line">    at java.util.concurrent.ForkJoinPool$WorkQueue.runTask(ForkJoinPool.java:1056)</span><br><span class="line">    at java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1692)</span><br><span class="line">    at java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:157)</span><br><span class="line">Caused by: java.lang.RuntimeException: task2 RuntimeException</span><br><span class="line">    at com.example.demo.ThreadTest.lambda$whenCompleteDemo$5(ThreadTest.java:44)</span><br><span class="line">    at java.util.concurrent.CompletableFuture$AsyncSupply.run(CompletableFuture.java:1590)</span><br><span class="line">    ... 5 more</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="handle"><a href="#handle" class="headerlink" title="handle"></a>handle</h4><ul>
<li>运行完成时，对结果的处理。这里的完成时有两种情况，<ul>
<li>正常执行，返回值</li>
<li>遇到异常抛出造成程序的中断。</li>
</ul>
</li>
<li>异常不会被抛到外层，不会造成外部线程因为异常中断</li>
<li>public <U> CompletableFuture<U> handle(BiFunction&lt;? super T, Throwable, ? extends U&gt; fn) </li>
<li>public <U> CompletableFuture<U> handleAsync(BiFunction&lt;? super T, Throwable, ? extends U&gt; fn) </li>
<li>public <U> CompletableFuture<U> handleAsync(BiFunction&lt;? super T, Throwable, ? extends U&gt; fn, Executor executor) <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public static void handleDemo() &#123;</span><br><span class="line">    CompletableFuture&lt;String&gt; task1 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        sleep(10);</span><br><span class="line">        return &quot;task 1&quot;;</span><br><span class="line">    &#125;);</span><br><span class="line">    CompletableFuture&lt;String&gt; task2 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        sleep(20);</span><br><span class="line">        throw new RuntimeException(&quot;task2 RuntimeException&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    String task1res = task1.handle((res, exp) -&gt; &#123;</span><br><span class="line">        println(&quot;task1 res:&quot; + res);</span><br><span class="line">        println(&quot;task1 exp:&quot; + exp);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;).join();</span><br><span class="line">    println(task1res);</span><br><span class="line">    String task2res = task2.handle((res, exp) -&gt; &#123;</span><br><span class="line">        println(&quot;task2 res:&quot; + res);</span><br><span class="line">        println(&quot;task2 exp:&quot; + exp.getMessage());</span><br><span class="line">        return res;</span><br><span class="line">    &#125;).join();</span><br><span class="line">    println(task2res);</span><br><span class="line">&#125;</span><br><span class="line">--------- 输出 -----------</span><br><span class="line">2019-06-23 19:50:53.542 ForkJoinPool.commonPool-worker-1: task1 res:task 1</span><br><span class="line">2019-06-23 19:50:53.543 ForkJoinPool.commonPool-worker-1: task1 exp:null</span><br><span class="line">2019-06-23 19:50:53.543 main: task 1</span><br><span class="line">2019-06-23 19:50:53.552 ForkJoinPool.commonPool-worker-2: task2 res:null</span><br><span class="line">2019-06-23 19:50:53.552 ForkJoinPool.commonPool-worker-2: task2 exp:java.lang.RuntimeException: task2 RuntimeException</span><br><span class="line">2019-06-23 19:50:53.552 main: null</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="exceptionally"><a href="#exceptionally" class="headerlink" title="exceptionally"></a>exceptionally</h4><ul>
<li>异常处理逻辑，可以设置异常情况下的返回值</li>
<li>public CompletionStage<T> exceptionally(Function&lt;Throwable, ? extends T&gt; fn)<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public static void exceptionallyDemo() &#123;</span><br><span class="line">    Object result = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        sleep(20);</span><br><span class="line">        throw new RuntimeException(&quot;task2 RuntimeException&quot;);</span><br><span class="line">    &#125;).exceptionally(e-&gt;&#123;</span><br><span class="line">        System.out.println(&quot;exceptionally: &quot; +e);</span><br><span class="line">        return e.getMessage();</span><br><span class="line">    &#125;).join();</span><br><span class="line">    System.out.println(&quot;exceptionallyDemo: &quot; +result);</span><br><span class="line">&#125;</span><br><span class="line">--------- 输出 -----------</span><br><span class="line">exceptionally: java.util.concurrent.CompletionException: java.lang.RuntimeException: task2 RuntimeException</span><br><span class="line">exceptionallyDemo: java.lang.RuntimeException: task2 RuntimeException</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h3><ul>
<li><p>public boolean isDone()</p>
<ul>
<li>是否已经完成（包括正常完成，异常完成，取消完成）</li>
</ul>
</li>
<li><p>public T get() throws InterruptedException, ExecutionException</p>
<ul>
<li>阻塞方式获取结果</li>
</ul>
</li>
<li><p>public T get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException</p>
<ul>
<li>带超时方式的阻塞方式获取结果</li>
</ul>
</li>
<li><p>public T join() </p>
<ul>
<li>阻塞至任务完成。会抛出CompletionException(unchecked类型)</li>
</ul>
</li>
<li><p>public T getNow(T valueIfAbsent) </p>
<ul>
<li>立即获取结果，如果任务没有执行完成，则返回valueIfAbsent</li>
</ul>
</li>
<li><p>public boolean complete(T value)</p>
<ul>
<li>如果任务还没有执行完成，则用当前值去替换完成值，否则继续使用原始值。  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">private static void completeDemo() &#123;</span><br><span class="line">    println(&quot;complete start&quot;);</span><br><span class="line">    CompletableFuture&lt;String&gt; task = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        println(&quot;runAsync start&quot;);</span><br><span class="line">        sleep(2000);</span><br><span class="line">        println(&quot;runAsync end&quot;);</span><br><span class="line">        return &quot;task run finish&quot;;</span><br><span class="line">    &#125;);</span><br><span class="line">    boolean complete = task.complete(&quot;finish&quot;);</span><br><span class="line">    System.out.println(&quot;complete:&quot;+complete);</span><br><span class="line">    System.out.println(&quot;task:&quot;+task.join());</span><br><span class="line">    println(&quot;complete end&quot;);</span><br><span class="line">&#125;</span><br><span class="line">--------- 输出 -----------</span><br><span class="line">2019-06-23 20:55:19.491 main: complete start</span><br><span class="line">complete:true</span><br><span class="line">task:finish</span><br><span class="line">2019-06-23 20:55:19.547 main: complete end</span><br><span class="line">------------------------------------------------------------------------</span><br><span class="line">private static void completeDemo() &#123;</span><br><span class="line">    println(&quot;complete start&quot;);</span><br><span class="line">    CompletableFuture&lt;String&gt; task = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        println(&quot;runAsync start&quot;);</span><br><span class="line">        sleep(1);</span><br><span class="line">        println(&quot;runAsync end&quot;);</span><br><span class="line">        return &quot;task run finish&quot;;</span><br><span class="line">    &#125;);</span><br><span class="line">    sleep(10);</span><br><span class="line">    boolean complete = task.complete(&quot;finish&quot;);</span><br><span class="line">    System.out.println(&quot;complete:&quot;+complete);</span><br><span class="line">    System.out.println(&quot;task:&quot;+task.join());</span><br><span class="line">    println(&quot;complete end&quot;);</span><br><span class="line">&#125;</span><br><span class="line">--------- 输出 -----------</span><br><span class="line">2019-06-23 20:59:32.375 main: complete start</span><br><span class="line">2019-06-23 20:59:32.426 ForkJoinPool.commonPool-worker-1: runAsync start</span><br><span class="line">2019-06-23 20:59:32.428 ForkJoinPool.commonPool-worker-1: runAsync end</span><br><span class="line">complete:false</span><br><span class="line">task:task run finish</span><br><span class="line">2019-06-23 20:59:32.437 main: complete end</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>public boolean completeExceptionally(Throwable ex)</p>
<ul>
<li>如果任务还没有执行完成，则以异常的方式中断执行（调用join方法会抛出该异常），如果执行完成,则返回false，并正常执行  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">    private static void completeExceptionallyDemo() &#123;</span><br><span class="line">    println(&quot;completeExceptionally start&quot;);</span><br><span class="line">    CompletableFuture&lt;String&gt; task = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        println(&quot;supplyAsync start&quot;);</span><br><span class="line">        sleep(1);</span><br><span class="line">        println(&quot;supplyAsync end&quot;);</span><br><span class="line">        return &quot;task run finish&quot;;</span><br><span class="line">    &#125;);</span><br><span class="line">    sleep(10);</span><br><span class="line">    boolean complete = task.completeExceptionally(new NullPointerException(&quot;Test Null&quot;));</span><br><span class="line">    System.out.println(&quot;complete:&quot;+complete);</span><br><span class="line">    System.out.println(&quot;task:&quot;+task.join());</span><br><span class="line">    println(&quot;complete 1 end&quot;);</span><br><span class="line"></span><br><span class="line">    task = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        println(&quot;supplyAsync start&quot;);</span><br><span class="line">        sleep(1);</span><br><span class="line">        println(&quot;supplyAsync end&quot;);</span><br><span class="line">        return &quot;task run finish&quot;;</span><br><span class="line">    &#125;);</span><br><span class="line">    complete = task.completeExceptionally(new NullPointerException(&quot;Test Null&quot;));</span><br><span class="line">    System.out.println(&quot;complete:&quot;+complete);</span><br><span class="line">    System.out.println(&quot;task:&quot;+task.join());</span><br><span class="line">&#125;</span><br><span class="line">--------- 输出 -----------</span><br><span class="line">2019-06-23 21:11:48.276 main: completeExceptionally start</span><br><span class="line">2019-06-23 21:11:48.330 ForkJoinPool.commonPool-worker-1: supplyAsync start</span><br><span class="line">2019-06-23 21:11:48.331 ForkJoinPool.commonPool-worker-1: supplyAsync end</span><br><span class="line">complete:false</span><br><span class="line">task:task run finish</span><br><span class="line">2019-06-23 21:11:48.340 main: complete 1 end</span><br><span class="line">complete:true</span><br><span class="line">Exception in thread &quot;main&quot; java.util.concurrent.CompletionException: java.lang.NullPointerException: Test Null</span><br><span class="line">    at java.util.concurrent.CompletableFuture.reportJoin(CompletableFuture.java:375)</span><br><span class="line">    at java.util.concurrent.CompletableFuture.join(CompletableFuture.java:1934)</span><br><span class="line">    at com.example.demo.ThreadTest.completeExceptionallyDemo(ThreadTest.java:35)</span><br><span class="line">    at com.example.demo.ThreadTest.main(ThreadTest.java:9)</span><br><span class="line">Caused by: java.lang.NullPointerException: Test Null</span><br><span class="line">    at com.example.demo.ThreadTest.completeExceptionallyDemo(ThreadTest.java:33)</span><br><span class="line">    ... 1 more</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>public CompletableFuture<T> toCompletableFuture()</p>
<ul>
<li>返回CompletableFuture对象，实际代码中返回this</li>
</ul>
</li>
<li><p>public boolean cancel(boolean mayInterruptIfRunning)</p>
<ul>
<li>取消任务，mayInterruptIfRunning在当前实现没有任何作用。。（醉了）</li>
<li>任务取消后如果执行join方法会抛出CancellationException异常。  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">private static void cancelDemo() &#123;</span><br><span class="line">    CompletableFuture&lt;Void&gt; future = CompletableFuture.runAsync(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            println(&quot;Start&quot;);</span><br><span class="line">            sleep(1000);</span><br><span class="line">            println(&quot;End&quot;);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    sleep(10);</span><br><span class="line">    boolean cancel = future.cancel(true);</span><br><span class="line">    println(cancel);</span><br><span class="line">    System.out.println(&quot;----------------------------------&quot;);</span><br><span class="line">    future = CompletableFuture.runAsync(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            println(&quot;Start&quot;);</span><br><span class="line">            sleep(10);</span><br><span class="line">            println(&quot;End&quot;);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    sleep(100);</span><br><span class="line">    cancel = future.cancel(true);</span><br><span class="line">    println(cancel);</span><br><span class="line">&#125;</span><br><span class="line">--------- 输出 -----------</span><br><span class="line">2019-06-23 21:56:33.060 ForkJoinPool.commonPool-worker-1: Start</span><br><span class="line">2019-06-23 21:56:33.072 main: true</span><br><span class="line">----------------------------------</span><br><span class="line">2019-06-23 21:56:33.075 ForkJoinPool.commonPool-worker-2: Start</span><br><span class="line">2019-06-23 21:56:33.086 ForkJoinPool.commonPool-worker-2: End</span><br><span class="line">2019-06-23 21:56:33.176 main: false</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>public boolean isCancelled()</p>
<ul>
<li>返回当前任务是否已经被取消</li>
</ul>
</li>
<li><p>public boolean isCompletedExceptionally()</p>
<ul>
<li>返回当前任务是否异常方式中断</li>
</ul>
</li>
<li><p>public void obtrudeValue(T value)</p>
<ul>
<li>将future的结果强制更改为value，无论是否发生异常</li>
</ul>
</li>
<li><p>public void obtrudeException(Throwable ex)</p>
<ul>
<li>将future的结果强制更改为异常，只要调用get或者join均会抛出该异常,同时会修改isCompletedExceptionally的结果</li>
</ul>
</li>
<li><p>public int getNumberOfDependents()</p>
<ul>
<li>返回有多少个后续stage依赖当前stage  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">private static void getNumberOfDependentsDemo() &#123;</span><br><span class="line">    CompletableFuture&lt;String&gt; t1 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        sleep(1000);</span><br><span class="line">        return &quot;1&quot;;</span><br><span class="line">    &#125;);</span><br><span class="line">    CompletableFuture&lt;String&gt; t2 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        sleep(1000);</span><br><span class="line">        return &quot;2&quot;;</span><br><span class="line">    &#125;);</span><br><span class="line">    sleep(10);</span><br><span class="line">    println(t1.getNumberOfDependents());</span><br><span class="line">    println(t2.getNumberOfDependents());</span><br><span class="line">    CompletableFuture&lt;Void&gt; all = CompletableFuture.allOf(t1, t2);</span><br><span class="line">    println(all.isDone());</span><br><span class="line">    println(t1.getNumberOfDependents());</span><br><span class="line">    println(t2.getNumberOfDependents());</span><br><span class="line">    all.join();</span><br><span class="line">    println(t1.getNumberOfDependents());</span><br><span class="line">    println(t2.getNumberOfDependents());</span><br><span class="line">&#125;</span><br><span class="line">--------- 输出 -----------</span><br><span class="line">2019-06-23 22:26:45.132 main: 0</span><br><span class="line">2019-06-23 22:26:45.133 main: 0</span><br><span class="line">2019-06-23 22:26:45.133 main: false</span><br><span class="line">2019-06-23 22:26:45.133 main: 1</span><br><span class="line">2019-06-23 22:26:45.133 main: 1</span><br><span class="line">2019-06-23 22:26:46.122 main: 0</span><br><span class="line">2019-06-23 22:26:46.122 main: 0</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/6bac52527ca4">https://www.jianshu.com/p/6bac52527ca4</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/558b090ae4bb">https://www.jianshu.com/p/558b090ae4bb</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jb51.net/article/51163.htm">https://www.jb51.net/article/51163.htm</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/dennyzhangdd/p/7010972.html">https://www.cnblogs.com/dennyzhangdd/p/7010972.html</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html?is-external=true">https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html?is-external=true</a></li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://eviltuzki.top/2019/06/13/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Eviltuzki">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eviltuzki">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/06/13/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E8%AF%A6%E8%A7%A3/" class="post-title-link" itemprop="url">I/O 多路复用之select、poll、epoll详解</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-06-13 00:00:00" itemprop="dateCreated datePublished" datetime="2019-06-13T00:00:00+08:00">2019-06-13</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/IO/" itemprop="url" rel="index"><span itemprop="name">IO</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <hr>
<p>select，poll，epoll都是IO多路复用的机制。I&#x2F;O多路复用就是通过一种机制，一个进程可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。但select，poll，epoll本质上都是同步I&#x2F;O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I&#x2F;O则无需自己负责进行读写，异步I&#x2F;O的实现会负责把数据从内核拷贝到用户空间。</p>
<hr>
<h2 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h2><h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><ul>
<li>基本原理：<ul>
<li>select 函数监视的文件描述符分3类，分别是writefds、readfds、和exceptfds。</li>
<li>调用后select函数会阻塞，直到有描述符就绪（有数据 可读、可写、或者有except），或者超时（timeout指定等待时间，如果立即返回设为null即可），函数返回。</li>
<li>当select函数返回后，可以通过遍历fdset，来找到就绪的描述符。</li>
</ul>
</li>
<li>select目前几乎在所有的平台上支持，其良好跨平台支持也是它的一个优点。</li>
<li>select最大的缺陷就是单个进程所打开的FD是有一定限制的，它由FD_SETSIZE设置，默认值是1024。<ul>
<li>一般来说这个数目和系统内存关系很大，具体数目可以cat &#x2F;proc&#x2F;sys&#x2F;fs&#x2F;file-max察看。32位机默认是1024个。64位机默认是2048.</li>
</ul>
</li>
<li>对socket进行扫描时是线性扫描，即采用轮询的方法，效率较低。<ul>
<li>当套接字比较多的时候，每次select()都要通过遍历FD_SETSIZE个Socket来完成调度，不管哪个Socket是活跃的，都遍历一遍。这会浪费很多CPU时间。如果能给套接字注册某个回调函数，当他们活跃时，自动完成相关操作，那就避免了轮询，这正是epoll与kqueue做的。</li>
</ul>
</li>
<li>需要维护一个用来存放大量fd的数据结构，这样会使得用户空间和内核空间在传递该结构时复制开销大。</li>
<li>简述：1024</li>
</ul>
<h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h3><ul>
<li>基本原理：<ul>
<li>poll本质上和select没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态。</li>
<li>如果设备就绪则在设备等待队列中加入一项并继续遍历，如果遍历完所有fd后没有发现就绪设备，则挂起当前进程，直到设备就绪或者主动超时，被唤醒后它又要再次遍历fd。</li>
<li>这个过程经历了多次无谓的遍历。</li>
</ul>
</li>
<li>pollfd结构包含了要监视的event和发生的event，不再使用select“参数-值”传递的方式。</li>
<li>同时，pollfd并没有最大数量限制（但是数量过大后性能也是会下降）。</li>
<li>和select函数一样，poll返回后，需要轮询pollfd来获取就绪的描述符。</li>
<li>poll还有一个特点是“水平触发”，如果报告了fd后，没有被处理，那么下次poll时会再次报告该fd。</li>
<li>从上面看，select和poll都需要在返回后，通过遍历文件描述符来获取已经就绪的socket。</li>
<li>事实上，同时连接的大量客户端在一时刻可能只有很少的处于就绪状态，因此随着监视的描述符数量的增长，其效率也会线性下降。</li>
<li>简述：鸡肋</li>
</ul>
<h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><ul>
<li>epoll是在2.6内核中提出的，是之前的select和poll的增强版本。</li>
<li>相对于select和poll来说，epoll更加灵活，没有描述符限制。</li>
<li>epoll使用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的copy只需一次。</li>
<li>没有最大并发连接的限制，能打开的FD的上限远大于1024（1G的内存上能监听约10万个端口）。</li>
<li>效率提升，不是轮询的方式，不会随着FD数目的增加效率下降。<ul>
<li>只有活跃可用的FD才会调用callback函数；即Epoll最大的优点就在于它只管你“活跃”的连接，而跟连接总数无关，因此在实际的网络环境中，Epoll的效率就会远远高于select和poll。</li>
</ul>
</li>
<li>内存拷贝，利用mmap()文件映射内存加速与内核空间的消息传递；即epoll使用mmap减少复制开销。</li>
<li>简述：杀手锏</li>
</ul>
<h4 id="epoll工作模式"><a href="#epoll工作模式" class="headerlink" title="epoll工作模式"></a>epoll工作模式</h4><ul>
<li>epoll对文件描述符的操作有两种模式：LT（level trigger）和ET（edge trigger）。LT模式是默认模式，LT模式与ET模式的区别如下：<ul>
<li>LT模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序可以不立即处理该事件。下次调用epoll_wait时，会再次响应应用程序并通知此事件。</li>
<li>ET模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序必须立即处理该事件。如果不处理，下次调用epoll_wait时，不会再次响应应用程序并通知此事件。</li>
</ul>
</li>
</ul>
<h5 id="LT模式"><a href="#LT模式" class="headerlink" title="LT模式"></a>LT模式</h5><ul>
<li>LT(level triggered)是缺省的工作方式，并且同时支持block和no-block socket.在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的fd进行IO操作。如果你不作任何操作，内核还是会继续通知你的。</li>
</ul>
<h5 id="ET模式"><a href="#ET模式" class="headerlink" title="ET模式"></a>ET模式</h5><ul>
<li>ET(edge-triggered)是高速工作方式，只支持no-block socket。在这种模式下，当描述符从未就绪变为就绪时，内核通过epoll告诉你。然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知，直到你做了某些操作导致那个文件描述符不再为就绪状态了(比如，你在发送，接收或者接收请求，或者发送接收的数据少于一定量时导致了一个EWOULDBLOCK 错误）。但是请注意，如果一直不对这个fd作IO操作(从而导致它再次变成未就绪)，内核不会发送更多的通知(only once)</li>
<li>ET模式在很大程度上减少了epoll事件被重复触发的次数，因此效率要比LT模式高。epoll工作在ET模式的时候，必须使用非阻塞套接口，以避免由于一个文件句柄的阻塞读&#x2F;阻塞写操作把处理多个文件描述符的任务饿死。</li>
</ul>
<h4 id="epoll总结"><a href="#epoll总结" class="headerlink" title="epoll总结"></a>epoll总结</h4><ul>
<li>在 select&#x2F;poll中，进程只有在调用一定的方法后，内核才对所有监视的文件描述符进行扫描，而<em>epoll事先通过epoll_ctl()来注册一 个文件描述符，一旦基于某个文件描述符就绪时，内核会采用类似callback的回调机制，迅速激活这个文件描述符，当进程调用epoll_wait() 时便得到通知。</em>(此处去掉了遍历文件描述符，而是通过监听回调的的机制。这正是epoll的魅力所在。)</li>
<li>epoll的优点主要是一下几个方面：<ul>
<li>监视的描述符数量不受限制，它所支持的FD上限是最大可以打开文件的数目，这个数字一般远大于2048,举个例子,在1GB内存的机器上大约是10万左 右，具体数目可以cat &#x2F;proc&#x2F;sys&#x2F;fs&#x2F;file-max察看,一般来说这个数目和系统内存关系很大。select的最大缺点就是进程打开的fd是有数量限制的。这对 于连接数量比较大的服务器来说根本不能满足。虽然也可以选择多进程的解决方案( Apache就是这样实现的)，不过虽然linux上面创建进程的代价比较小，但仍旧是不可忽视的，加上进程间数据同步远比不上线程间同步的高效，所以也不是一种完美的方案。</li>
<li>IO的效率不会随着监视fd的数量的增长而下降。epoll不同于select和poll轮询的方式，而是通过每个fd定义的回调函数来实现的。只有就绪的fd才会执行回调函数。</li>
<li>如果没有大量的idle -connection或者dead-connection，epoll的效率并不会比select&#x2F;poll高很多，但是当遇到大量的idle- connection，就会发现epoll的效率大大高于select&#x2F;poll。</li>
</ul>
</li>
</ul>
<h2 id="select、poll、epoll区别"><a href="#select、poll、epoll区别" class="headerlink" title="select、poll、epoll区别"></a>select、poll、epoll区别</h2><p>1、支持一个进程所能打开的最大连接数<br><img src="/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E8%AF%A6%E8%A7%A3/1.png" alt="最大连接数"><br>2、FD剧增后带来的IO效率问题<br><img src="/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E8%AF%A6%E8%A7%A3/2.png" alt="IO效率问题"><br>3、消息传递方式<br><img src="/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E8%AF%A6%E8%A7%A3/3.png" alt="消息传递方式"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://eviltuzki.top/2019/06/12/%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4%E4%B8%8E%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Eviltuzki">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eviltuzki">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/06/12/%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4%E4%B8%8E%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4/" class="post-title-link" itemprop="url">用户空间与内核空间</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-06-12 00:00:00" itemprop="dateCreated datePublished" datetime="2019-06-12T00:00:00+08:00">2019-06-12</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <hr>
<ul>
<li><p>我们知道现在操作系统都是采用虚拟存储器，那么对32位操作系统而言，它的寻址空间（虚拟存储空间）为4G（2的32次方）。</p>
</li>
<li><p>操心系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。为了保证用户进程不能直接操作内核，保证内核的安全，操心系统将虚拟空间划分为两部分，一部分为内核空间，一部分为用户空间。</p>
</li>
<li><p>针对linux操作系统而言，将最高的1G字节（从虚拟地址0xC0000000到0xFFFFFFFF），供内核使用，称为内核空间，而将较低的3G字节（从虚拟地址0x00000000到0xBFFFFFFF），供各个进程使用，称为用户空间。</p>
</li>
<li><p>每个进程可以通过系统调用进入内核，因此，Linux内核由系统内的所有进程共享。于是，从具体进程的角度来看，每个进程可以拥有4G字节的虚拟空间。</p>
</li>
<li><p>空间分配如下图所示：<br><img src="/%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4%E4%B8%8E%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4/1.png" alt="空间分配图"></p>
</li>
<li><p>有了用户空间和内核空间，整个linux内部结构可以分为三部分，从最底层到最上层依次是：硬件–&gt;内核空间–&gt;用户空间。如下图所示：<br><img src="/%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4%E4%B8%8E%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4/2.png" alt="linux内部结构图"></p>
</li>
<li><p>需要注意的细节问题：</p>
<ul>
<li>内核空间中存放的是内核代码和数据，而进程的用户空间中存放的是用户程序的代码和数据。不管是内核空间还是用户空间，它们都处于虚拟空间中。 </li>
<li>Linux使用两级保护机制：0级供内核使用，3级供用户程序使用。</li>
</ul>
</li>
<li><p>内核态与用户态：</p>
<ul>
<li>当一个任务（进程）执行系统调用而陷入内核代码中执行时，称进程处于内核运行态（内核态）。此时处理器处于特权级最高的（0级）内核代码中执行。当进程处于内核态时，执行的内核代码会使用当前进程的内核栈。每个进程都有自己的内核栈。</li>
<li>当进程在执行用户自己的代码时，则称其处于用户运行态（用户态）。此时处理器在特权级最低的（3级）用户代码中运行。当正在执行用户程序而突然被中断程序中断时，此时用户程序也可以象征性地称为处于进程的内核态。因为中断处理程序将使用当前进程的内核栈。</li>
</ul>
</li>
<li><p>参考资料：</p>
<ul>
<li>用户空间与内核空间，进程上下文与中断上下文[总结][<a target="_blank" rel="noopener" href="https://www.cnblogs.com/Anker/p/3269106.html]">https://www.cnblogs.com/Anker/p/3269106.html]</a></li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://eviltuzki.top/2019/06/02/Java%20NIO%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Eviltuzki">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eviltuzki">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/06/02/Java%20NIO%E5%AD%A6%E4%B9%A0/" class="post-title-link" itemprop="url">Java NIO学习笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-06-02 00:00:00" itemprop="dateCreated datePublished" datetime="2019-06-02T00:00:00+08:00">2019-06-02</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ul>
<li>内容基本来源:<ul>
<li><a target="_blank" rel="noopener" href="http://www.iocoder.cn/">http://www.iocoder.cn/</a></li>
<li><a target="_blank" rel="noopener" href="http://ifeve.com/">http://ifeve.com</a></li>
</ul>
</li>
</ul>
<h2 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h2><h3 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h3><ul>
<li>Nio Channel类似于Java Stream，但又有几点不同<ul>
<li>Channel是双向的，Stream是单向的</li>
<li>Channel可以非阻塞的进行读写操作，而Stream需要等待io操作完成，也就是阻塞的。</li>
<li>Channel的读操作或者写操作都是依赖Buffer的，Stream没有依赖</li>
</ul>
</li>
</ul>
<h4 id="ServerSocketChannel"><a href="#ServerSocketChannel" class="headerlink" title="ServerSocketChannel"></a>ServerSocketChannel</h4><ul>
<li>Java NIO中的 ServerSocketChannel 是一个可以监听新进来的TCP连接的通道, 就像标准IO中的ServerSocket一样。</li>
<li>ServerSocketChannel类在 java.nio.channels包中。</li>
</ul>
<h4 id="SocketChannel"><a href="#SocketChannel" class="headerlink" title="SocketChannel"></a>SocketChannel</h4><ul>
<li>Java NIO中的SocketChannel是一个连接到TCP网络套接字的通道。</li>
<li>可以通过以下2种方式创建SocketChannel：<ul>
<li>打开一个SocketChannel并连接到互联网上的某台服务器。</li>
<li>一个新连接到达ServerSocketChannel时，会创建一个SocketChannel。</li>
</ul>
</li>
<li>非阻塞模式与选择器搭配会工作的更好，通过将一或多个SocketChannel注册到Selector，可以询问选择器哪个通道已经准备好了读取，写入等。</li>
</ul>
<h4 id="DatagramChannel"><a href="#DatagramChannel" class="headerlink" title="DatagramChannel"></a>DatagramChannel</h4><ul>
<li>Java NIO中的DatagramChannel是一个能收发UDP包的通道。</li>
<li>因为UDP是无连接的网络协议，所以不能像其它通道那样读取和写入。</li>
<li>它发送和接收的是数据包。</li>
</ul>
<h4 id="FileChannel"><a href="#FileChannel" class="headerlink" title="FileChannel"></a>FileChannel</h4><ul>
<li>Java NIO中的FileChannel是一个连接到文件的通道。可以通过文件通道读写文件。</li>
<li>FileChannel无法设置为非阻塞模式，它总是运行在阻塞模式下。</li>
</ul>
<h3 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h3><ul>
<li>一个 Buffer，本质上是内存中的一块，我们可以将数据写入这块内存，之后从这块内存获取数据。通过将这块内存封装成 NIO Buffer 对象，并提供了一组常用的方法，方便我们对该块内存的读写。</li>
<li>基本属性<ul>
<li>capacity<ul>
<li>属性，容量，Buffer 能容纳的数据元素的最大值。这一容量在 Buffer 创建时被赋值，并且永远不能被修改。</li>
</ul>
</li>
<li>limit<ul>
<li>属性，上限。</li>
<li>写模式下，代表最大能写入的数据上限位置，这个时候 limit 等于 capacity 。</li>
<li>读模式下，在 Buffer 完成所有数据写入后，通过调用 #flip() 方法，切换到读模式。此时，limit 等于 Buffer 中实际的数据大小。因为 Buffer 不一定被写满，所以不能使用 capacity 作为实际的数据大小。</li>
</ul>
</li>
<li>position<ul>
<li>position 属性，位置，初始值为 0 。</li>
<li>写模式下，每往 Buffer 中写入一个值，position 就自动加 1 ，代表下一次的写入位置。</li>
<li>读模式下，每从 Buffer 中读取一个值，position 就自动加 1 ，代表下一次的读取位置。( 和写模式类似 )</li>
</ul>
</li>
<li>mark <ul>
<li>属性，标记，通过 #mark() 方法，记录当前 position ；通过 reset() 方法，恢复 position 为标记。</li>
<li>写模式下，标记上一次写位置。</li>
<li>读模式下，标记上一次读位置。</li>
</ul>
</li>
<li>关系<ul>
<li>mark &lt;&#x3D; position &lt;&#x3D; limit &lt;&#x3D; capacity</li>
</ul>
</li>
</ul>
</li>
<li>创建Buffer<ul>
<li>每个 Buffer 实现类，都提供了 #allocate(int capacity) 静态方法，帮助我们快速实例化一个 Buffer 对象。<ul>
<li>ByteBuffer 实际是个抽象类，返回的是它的基于堆内( Non-Direct )内存的实现类 HeapByteBuffer 的对象。</li>
</ul>
</li>
<li>每个 Buffer 实现类，都提供了 #wrap(array) 静态方法，帮助我们将其对应的数组包装成一个 Buffer 对象。<ul>
<li>和 #allocate(int capacity) 静态方法一样，返回的也是 HeapByteBuffer 的对象。</li>
</ul>
</li>
<li>每个 Buffer 实现类，都提供了 #allocateDirect(int capacity) 静态方法，帮助我们快速实例化一个 Buffer 对象。<ul>
<li>和 #allocate(int capacity) 静态方法不一样，返回的是它的基于堆外( Direct )内存的实现类 DirectByteBuffer 的对象。</li>
</ul>
</li>
</ul>
</li>
<li>向 Buffer 写入数据<ul>
<li>每个 Buffer 实现类，都提供了 #put(…) 方法，向 Buffer 写入数据。</li>
<li>对于 Buffer 来说，有一个非常重要的操作就是，我们要讲来自 Channel 的数据写入到 Buffer 中。</li>
<li>在系统层面上，这个操作我们称为读操作，因为数据是从外部( 文件或者网络等 )读取到内存中。</li>
<li>通常在说 NIO 的读操作的时候，我们说的是从 Channel 中读数据到 Buffer 中，对应的是对 Buffer 的写入操作</li>
</ul>
</li>
<li>从 Buffer 读取数据<ul>
<li>每个 Buffer 实现类，都提供了 #get(…) 方法，从 Buffer 读取数据。</li>
<li>对于 Buffer 来说，还有一个非常重要的操作就是，我们要讲来向 Channel 的写入 Buffer 中的数据。</li>
<li>在系统层面上，这个操作我们称为写操作，因为数据是从内存中写入到外部( 文件或者网络等 )。</li>
</ul>
</li>
<li>rewind()  flip()   clear()<ul>
<li>flip  <ul>
<li>如果要读取 Buffer 中的数据，需要切换模式，从写模式切换到读模式。</li>
</ul>
</li>
<li>rewind<ul>
<li>可以重置 position 的值为 0 。因此，我们可以重新读取和写入 Buffer 了。</li>
<li>该方法主要针对于读模式，所以可以翻译为“倒带”。</li>
</ul>
</li>
<li>clear<ul>
<li>可以“重置” Buffer 的数据。因此，我们可以重新读取和写入 Buffer 了。</li>
<li>该方法主要针对于写模式。</li>
<li>Buffer 的数据实际并未清理掉</li>
</ul>
</li>
</ul>
</li>
<li>mark() 搭配 reset()<ul>
<li>mark<ul>
<li>保存当前的 position 到 mark 中。</li>
</ul>
</li>
<li>reset<ul>
<li>恢复当前的 postion 为 mark 。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="关于-Direct-Buffer-和-Non-Direct-Buffer-的区别"><a href="#关于-Direct-Buffer-和-Non-Direct-Buffer-的区别" class="headerlink" title="关于 Direct Buffer 和 Non-Direct Buffer 的区别"></a>关于 Direct Buffer 和 Non-Direct Buffer 的区别</h4><ul>
<li>Direct Buffer:<ul>
<li>所分配的内存不在 JVM 堆上, 不受 GC 的管理.(但是 Direct Buffer 的 Java 对象是由 GC 管理的, 因此当发生 GC, 对象被回收时, Direct Buffer 也会被释放)</li>
<li>因为 Direct Buffer 不在 JVM 堆上分配, 因此 Direct Buffer 对应用程序的内存占用的影响就不那么明显(实际上还是占用了这么多内存, 但是 JVM 不好统计到非 JVM 管理的内存.)</li>
<li>申请和释放 Direct Buffer 的开销比较大. 因此正确的使用 Direct Buffer 的方式是在初始化时申请一个 Buffer, 然后不断复用此 buffer, 在程序结束后才释放此 buffer.</li>
<li>使用 Direct Buffer 时, 当进行一些底层的系统 IO 操作时, 效率会比较高, 因为此时 JVM 不需要拷贝 buffer 中的内存到中间临时缓冲区中.</li>
</ul>
</li>
<li>Non-Direct Buffer:<ul>
<li>直接在 JVM 堆上进行内存的分配, 本质上是 byte[] 数组的封装.</li>
<li>因为 Non-Direct Buffer 在 JVM 堆中, 因此当进行操作系统底层 IO 操作中时, 会将此 buffer 的内存复制到中间临时缓冲区中. 因此 Non-Direct Buffer 的效率就较低.</li>
</ul>
</li>
</ul>
<h3 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h3><ul>
<li>Selector ， 一般称为选择器。它是 Java NIO 核心组件中的一个，用于轮询一个或多个 NIO Channel 的状态是否处于可读、可写。如此，一个线程就可以管理多个 Channel ，也就说可以管理多个网络连接。也因此，Selector 也被称为多路复用器。</li>
<li>那么 Selector 是如何轮询的呢？<ul>
<li>首先，需要将 Channel 注册到 Selector 中，这样 Selector 才知道哪些 Channel 是它需要管理的。</li>
<li>之后，Selector 会不断地轮询注册在其上的 Channel 。如果某个 Channel 上面发生了读或者写事件，这个 Channel 就处于就绪状态，会被 Selector 轮询出来，然后通过 SelectionKey 可以获取就绪 Channel 的集合，进行后续的 I&#x2F;O 操作。</li>
</ul>
</li>
<li>优缺点<ul>
<li>优点<ul>
<li>使用一个线程能够处理多个 Channel 的优点是，只需要更少的线程来处理 Channel 。</li>
<li>事实上，可以使用一个线程处理所有的 Channel 。</li>
<li>对于操作系统来说，线程之间上下文切换的开销很大，而且每个线程都要占用系统的一些资源( 例如 CPU、内存 )。因此，使用的线程越少越好。</li>
</ul>
</li>
<li>缺点<ul>
<li>因为在一个线程中使用了多个 Channel ，因此会造成每个 Channel 处理效率的降低。</li>
</ul>
</li>
</ul>
</li>
<li>创建 Selector<ul>
<li>通过 #open() 方法，我们可以创建一个 Selector 对象。代码如下：</li>
</ul>
</li>
<li>注册 Chanel 到 Selector 中<ul>
<li>为了让 Selector 能够管理 Channel ，我们需要将 Channel 注册到 Selector 中。</li>
<li>如果一个 Channel 要注册到 Selector 中，那么该 Channel 必须是非阻塞。</li>
<li>FileChannel 是不能够注册到 Channel 中的，因为它是阻塞的。</li>
<li>监听四种不同类型的事件：<ul>
<li>Connect ：连接完成事件( TCP 连接 )，仅适用于客户端，对应 SelectionKey.OP_CONNECT 。</li>
<li>Accept ：接受新连接事件，仅适用于服务端，对应 SelectionKey.OP_ACCEPT 。</li>
<li>Read ：读事件，适用于两端，对应 SelectionKey.OP_READ ，表示 Buffer 可读。</li>
<li>Write ：写时间，适用于两端，对应 SelectionKey.OP_WRITE ，表示 Buffer 可写。</li>
</ul>
</li>
<li>Channel 触发了一个事件，意思是该事件已经就绪：<ul>
<li>一个 Client Channel Channel 成功连接到另一个服务器，称为“连接就绪”。</li>
<li>一个 Server Socket Channel 准备好接收新进入的连接，称为“接收就绪”。</li>
<li>一个有数据可读的 Channel ，可以说是“读就绪”。</li>
<li>一个等待写数据的 Channel ，可以说是“写就绪”。</li>
</ul>
</li>
</ul>
</li>
<li>SelectionKey 类<ul>
<li>调用 Channel 的 #register(…) 方法，向 Selector 注册一个 Channel 后，会返回一个 SelectionKey 对象。</li>
<li>SelectionKey 在 java.nio.channels 包下，被定义成一个抽象类，表示一个 Channel 和一个 Selector 的注册关系。</li>
<li>注册关系，包含如下内容：<ul>
<li>interest set: 感兴趣的事件集合。</li>
<li>ready set ：就绪的事件集合。</li>
<li>Channel</li>
<li>Selector</li>
<li>attachment ：可选的附加对象。可以向 SelectionKey 添加附加对象。</li>
</ul>
</li>
</ul>
</li>
<li>通过 Selector 选择 Channel<ul>
<li>在 Selector 中，提供三种类型的选择( select )方法，返回当前有感兴趣事件准备就绪的 Channel 数量。<ul>
<li>select() 阻塞到至少有一个 Channel 在你注册的事件上就绪了。</li>
<li>select(long timeout) 在 <code>#select()</code> 方法的基础上，增加超时机制。</li>
<li>selectNow() 和 <code>#select()</code> 方法不同，立即返回数量，而不阻塞。</li>
</ul>
</li>
<li>select 方法返回的 int 值，表示有多少 Channel 已经就绪。也就是自上次调用 select 方法后有多少 Channel 变成就绪状态。</li>
</ul>
</li>
<li>获取可操作的 Channel<ul>
<li>一旦调用了 select 方法，并且返回值表明有一个或更多个 Channel 就绪了，然后可以通过调用Selector 的 #selectedKeys() 方法，访问“已选择键集( selected key set )”中的就绪 Channel 。</li>
<li>注意，当有新增就绪的 Channel ，需要先调用 select 方法，才会添加到“已选择键集( selected key set )”中。否则，我们直接调用 #selectedKeys() 方法，是无法获得它们对应的 SelectionKey 们。</li>
</ul>
</li>
<li>唤醒 Selector 选择<ul>
<li>某个线程调用 #select() 方法后，发生阻塞了，即使没有通道已经就绪，也有办法让其从 #select() 方法返回。</li>
<li>只要让其它线程在第一个线程调用 select() 方法的那个 Selector 对象上，调用该 Selector 的 #wakeup() 方法，进行唤醒该 Selector 即可。</li>
<li>注意，如果有其它线程调用了 #wakeup() 方法，但当前没有线程阻塞在 #select() 方法上，下个调用 #select() 方法的线程会立即被唤醒。</li>
</ul>
</li>
<li>关闭 Selector<ul>
<li>当我们不再使用 Selector 时，可以调用 Selector 的 #close() 方法，将它进行关闭。<ul>
<li>Selector 相关的所有 SelectionKey 都会失效。</li>
<li>Selector 相关的所有 Channel 并不会关闭。</li>
</ul>
</li>
<li>此时若有线程阻塞在 #select() 方法上，也会被唤醒返回。</li>
</ul>
</li>
</ul>
<h2 id="NIO与BIO相比"><a href="#NIO与BIO相比" class="headerlink" title="NIO与BIO相比"></a>NIO与BIO相比</h2><h3 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h3><ul>
<li>基于缓冲区<ul>
<li>基于Buffer读取，将数据从Channel中读取到Buffer中，或者从buffer中将数据写回到channel中。因为数据已经读取到缓冲区当中，所以操作不需要顺序执行，增加其灵活性。</li>
</ul>
</li>
<li>非阻塞IO<ul>
<li>一个线程从channel中执行io操作的时候，无论是读取还是写入，都无需等待完成，都会直接返回，不会阻塞当前正在执行的线程。</li>
</ul>
</li>
<li>有选择器<ul>
<li>一个线程可以通过一个Selector管理多个Channel，选择器是实现非阻塞io的核心。</li>
<li>Selector内部自动为我们实现了轮训select操作，判断channel是否有已经就绪的io事件（连接，读，写等）</li>
</ul>
</li>
</ul>
<h3 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h3><ul>
<li>基于流(Stream)<ul>
<li>以流式方式进行处理，顺序的从一个stream中读取一个或者多个字节，直到读取完成。由于没有缓存区，不能随意更改读取指针的位置。</li>
</ul>
</li>
<li>阻塞IO<ul>
<li>一个线程操作io的时候，该线程会被阻塞，直到数据被读取或者写入完成。</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://eviltuzki.top/2019/05/08/MySQL%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93(4)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Eviltuzki">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eviltuzki">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/05/08/MySQL%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93(4)/" class="post-title-link" itemprop="url">MySQL学习总结(4)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-05-08 00:00:00" itemprop="dateCreated datePublished" datetime="2019-05-08T00:00:00+08:00">2019-05-08</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MySQL/" itemprop="url" rel="index"><span itemprop="name">MySQL</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p>根据加锁的范围，MySQL里面的锁大致可以分为全局锁，表级锁和行级锁。</p>
<h1 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h1><ul>
<li>MySql提供了一个加全局锁的方法，Flush tables with read lock(FTWRL)</li>
<li>适用场景：全库逻辑备份</li>
<li>阻塞: 数据更新语句，数据定义语句，更新类事务提交语句</li>
</ul>
<h1 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h1><ul>
<li>MySql中表级锁有两种：表锁 和 元数据锁</li>
</ul>
<h2 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h2><ul>
<li>表锁语法是: lock tables … read&#x2F;write</li>
<li>对于InnoDB这种支持行锁的引擎，一般不使用lock tables方式控制并发</li>
</ul>
<h2 id="元数据锁（matedata-lock，MDL）"><a href="#元数据锁（matedata-lock，MDL）" class="headerlink" title="元数据锁（matedata lock，MDL）"></a>元数据锁（matedata lock，MDL）</h2><ul>
<li>MDL不需要显示使用，在访问一个表的时候会被自动加上。</li>
<li>作用：保证读写的正确性。</li>
<li>增删改查操作自动加MDL读锁，修改表结构的时候加MDL写锁</li>
</ul>
<h1 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h1><ul>
<li>问题: 即使把所有的记录都加上锁，也还是阻止不了新插入的记录。</li>
</ul>
<h2 id="如何解决幻读问题"><a href="#如何解决幻读问题" class="headerlink" title="如何解决幻读问题"></a>如何解决幻读问题</h2><ul>
<li>产生幻读的原因是：行锁只能锁住行，新插入记录这个动作，要更新的是记录之间的间隙。</li>
<li>解决办法： InnoDB引入了新的锁，间隙锁(Gap Lock)</li>
<li>与间隙锁冲突的操作:往这个间隙中插入一条记录</li>
<li>间隙锁和行锁合称：next-key lock</li>
</ul>
<h1 id="加锁总结"><a href="#加锁总结" class="headerlink" title="加锁总结"></a>加锁总结</h1><ul>
<li><p>原则1：加锁的基本单位是next-key lock，是前开后闭区间。</p>
</li>
<li><p>原则2：查找过程中访问到的对象才会加锁。</p>
</li>
<li><p>优化1：索引上的等值查询，给唯一索引加锁的时候，next-key lock 退化为行锁。</p>
</li>
<li><p>优化2：索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，next-key lock退化为间隙锁。</p>
</li>
<li><p>Bug：唯一索引上的范围查询会访问到不满足条件的第一个值为止。</p>
</li>
<li><p>锁是加在索引上的</p>
</li>
<li><p>用lock in share mode来给行加读锁避免数据被更新的话，必须要绕过覆盖索引优化，查询字段中加入索引中不存在的字段。</p>
</li>
<li><p>分析加锁规则的时候可以用next-key lock来进行分析，但是具体执行的时候，是要分成间隙锁和行锁两阶段来执行的。</p>
</li>
</ul>
<hr>
<ul>
<li>源：&lt;极客时间&gt; MySQL实战45讲教程</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://eviltuzki.top/2019/05/07/MySQL%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93(3)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Eviltuzki">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eviltuzki">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/05/07/MySQL%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93(3)/" class="post-title-link" itemprop="url">MySQL学习总结(3)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-05-07 00:00:00" itemprop="dateCreated datePublished" datetime="2019-05-07T00:00:00+08:00">2019-05-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MySQL/" itemprop="url" rel="index"><span itemprop="name">MySQL</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><h1 id="索引常见模型"><a href="#索引常见模型" class="headerlink" title="索引常见模型"></a>索引常见模型</h1><ul>
<li>哈希表</li>
<li>适用于只有等值查询的场景</li>
<li>有序数组</li>
<li>适用于等值查询，范围查询</li>
<li>更新成本高，适用于静态存储引擎</li>
<li>搜索树</li>
<li>查询复杂度O(log(N))</li>
<li>更新操作复杂度O(log(N))</li>
<li>为了适配磁盘，往往使用N叉树</li>
</ul>
<h1 id="InnoDB索引模型"><a href="#InnoDB索引模型" class="headerlink" title="InnoDB索引模型"></a>InnoDB索引模型</h1><ul>
<li><p>表都是根据主键顺序以索引形式存放。</p>
</li>
<li><p>使用了B+树索引模型，数据存储在B+树中。</p>
</li>
<li><p>根据叶子节点内容，索引类型分主键索引和非主键索引</p>
</li>
<li><p>主键索引叶子节点存放的是整行的数据，也成为聚簇索引。</p>
</li>
<li><p>非主键索引叶子节点存放的是主键的值，非主键索引也成为二级索引</p>
</li>
<li><p>区别：基于非主键索引的查询需要多扫描一颗索引树。</p>
</li>
</ul>
<h1 id="索引维护"><a href="#索引维护" class="headerlink" title="索引维护"></a>索引维护</h1><ul>
<li>一个数据页满了，按照B+Tree算法，会新增加一个数据页，这个过程称为页分裂，会导致性能下降，空间利用率降低大概一半。</li>
<li>两个相邻的数据页利用率如果都很低，会做数据合并，也就是页分裂逆过程</li>
<li>B+树的插入可能会引起数据页的分裂，删除可能会引起数据页的合并，二者都是比较重的IO消耗，所以比较好的方式是顺序插入数据，这也是我们一般使用自增主键的原因之一</li>
<li>在Key-Value的场景下，只有一个索引且是唯一索引，则适合直接使用业务字段作为主键索引</li>
<li>非主键索引的叶子结点存储的是主键的值，所以主键字段占用空间不宜过大。同时，其查找数据的过程称为“回表”，需要先查找自己得到主键值，再在主键索引上边查找数据内容。</li>
<li>索引的实现由存储引擎来决定，InnoDB使用B+树（N叉树，比如1200叉树），把整颗树的高度维持在很小的范围内，同时在内存里缓存前面若干层的节点，可以极大地降低访问磁盘的次数，提高读的效率。</li>
</ul>
<h1 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h1><ul>
<li>回到主键索引树搜索的过程，我们称为回表</li>
<li>由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。</li>
</ul>
<h1 id="最左前缀原则"><a href="#最左前缀原则" class="headerlink" title="最左前缀原则"></a>最左前缀原则</h1><ul>
<li>B+ 树这种索引结构，可以利用索引的“最左前缀”，来定位记录。</li>
<li>在建立联合索引的时候，如何安排索引内的字段顺序</li>
<li>第一原则，如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是最需要有限考虑的。</li>
<li>再次考虑空间</li>
</ul>
<h1 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h1><ul>
<li>MySQL 5.6 引入的索引下推优化，可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。</li>
</ul>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><ul>
<li>满足语句需求的情况下， 尽量少地访问资源是数据库设计的重要原则之一。</li>
<li>设计表结构时，也要以减少资源消耗作为目标。</li>
</ul>
<hr>
<ul>
<li>源：&lt;极客时间&gt; MySQL实战45讲教程</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://eviltuzki.top/2019/05/06/MySQL%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93(2)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Eviltuzki">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eviltuzki">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/05/06/MySQL%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93(2)/" class="post-title-link" itemprop="url">MySQL学习总结(2)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-05-06 00:00:00" itemprop="dateCreated datePublished" datetime="2019-05-06T00:00:00+08:00">2019-05-06</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MySQL/" itemprop="url" rel="index"><span itemprop="name">MySQL</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h2><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ul>
<li>脏读</li>
<li>可重复读</li>
<li>幻读</li>
</ul>
<h2 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h2><ul>
<li>读未提交</li>
<li>一个事务还没提交的时候，其所作的变更可以被其他事务看到。</li>
<li>读提交</li>
<li>一个事务提交后，他做的变更才会被其他事务看到。</li>
<li>可重复读</li>
<li>一个事务执行的过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。</li>
<li>串行化</li>
<li>对于同一行记录，写会加写锁，读会加读锁，一旦出现读写锁冲突的时候，后访问的事务必须等前一个事务完成才能继续执行。</li>
</ul>
<h2 id="隔离级别实现"><a href="#隔离级别实现" class="headerlink" title="隔离级别实现"></a>隔离级别实现</h2><ul>
<li>数据库里面会创建一个视图，访问的时候以这个视图的逻辑结果为准。</li>
<li>可重复读，视图在事务启动时创建，这个事务存在期间都在用这个视图。</li>
<li>读提交，视图实在每个sql语句开始执行的时候创建</li>
<li>读未提交，直接返回记录最新值，没有视图概念</li>
<li>串行化，直接用加锁的方式避免并行访问</li>
<li>隔离的实现</li>
<li>每条记录在更新的时候都会同事记录一条回滚操作。记录上的最新值，通过回滚操作都可以得到前一个状态的值。</li>
<li>系统会在没有实物需要使用到这些回滚日志的时候，删除回滚日志。</li>
<li>不要使用长事务</li>
<li>长事务意味着系统里面会存在很老的事务视图。由于这些事务随时可能访问数据库里面的任何数据，所以这个事务提交之前，数据库里面会存储他可能用到的所有回滚记录，导致占用大量的存储空</li>
</ul>
<hr>
<ul>
<li>源：&lt;极客时间&gt; MySQL实战45讲教程</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Eviltuzki</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">59</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">73</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/eviltuzki" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;eviltuzki" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Eviltuzki</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
