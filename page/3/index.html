<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"eviltuzki.top","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Eviltuzki">
<meta property="og:url" content="https://eviltuzki.top/page/3/index.html">
<meta property="og:site_name" content="Eviltuzki">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Eviltuzki">
<meta property="article:tag" content="Java,ElasticSearch,Go">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://eviltuzki.top/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Eviltuzki</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Eviltuzki</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">一线码农一枚</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>日程表</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://eviltuzki.top/2019/06/30/Java%E9%9B%86%E5%90%88%E7%B1%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Eviltuzki">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eviltuzki">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/06/30/Java%E9%9B%86%E5%90%88%E7%B1%BB/" class="post-title-link" itemprop="url">Java 集合类整理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-06-30 00:00:00" itemprop="dateCreated datePublished" datetime="2019-06-30T00:00:00+08:00">2019-06-30</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h1><p>好像Java面试必不可少的一个问题就是，Java中集合有哪些？分别有什么特点。照搬各种《XXX从入门到放弃》，集合有2种类型，一个是有序可重复的List，一个是无序不可重复的Set，可是真的用起来的时候好像就不是简单的这样了。  </p>
<p>先来看一下集合的整体关系图(并发包中的集合没有考虑进来，仅看java.util包)<br><img src="/Java%E9%9B%86%E5%90%88%E7%B1%BB/Collection.png" alt="Java集合类">  </p>
<p>第一眼看上去我也懵，本来以为自己天天用的那些集合类已经差不多了，然后发现一坨坨的没见过没用过的。</p>
<h1 id="那就啃吧。。"><a href="#那就啃吧。。" class="headerlink" title="那就啃吧。。"></a>那就啃吧。。</h1><h2 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h2><ul>
<li>Collection应该是老大哥级别的了，算是集合类的鼻祖（迭代器忽略），定义了一个集合应该有的基本方法，包括增删迭代等，这个就不多说了。</li>
<li>1.8版本开始，增加了流式操作的几个default方法(先不关注了)</li>
</ul>
<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>List应该是集合中用的最多最多的了，平时搬砖，基本上几行代码就要加上一个List存储各种元素。忽略抽象方法，整理一下对应的实现类</p>
<h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><p>ArrayList应该是日常搬砖使用最多的的实现了，特点如下:</p>
<ul>
<li>底层实现是数组，对应代码:<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transient Object[] elementData;</span><br></pre></td></tr></table></figure></li>
<li>实现了动态扩容方法，简单说就是容量不够了，我就新建一个数组，然后将原来的数据拷贝到新数组中。从代码int newCapacity &#x3D; oldCapacity + (oldCapacity &gt;&gt; 1);中也可以看出来，每次扩容变为原本的1.5倍。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private void grow(int minCapacity) &#123;</span><br><span class="line">    // overflow-conscious code</span><br><span class="line">    int oldCapacity = elementData.length;</span><br><span class="line">    int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);</span><br><span class="line">    if (newCapacity - minCapacity &lt; 0)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    // minCapacity is usually close to size, so this is a win:</span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>线程不安全，所有方法没有加锁，多线程存在并发问题</li>
<li>因为底层实现是数组，所以随机读取速度很快，并不是说不适合插入数据，而是不适合在中间或者头部插入数据。因为插入数据之后，当前位置后面的元素都要往后移动，成本相对来说比较大了。代码如下:<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.arraycopy(elementData, index, elementData, index + 1, size - index);</span><br><span class="line">elementData[index] = element;</span><br></pre></td></tr></table></figure></li>
<li>删除操作也是同理，在末尾操作其实影响不大，但是在中间和数组起始位置操作成本就有点高了。</li>
<li>更新操作影响很小，直接找到对应数组下标，然后替换就可以了。</li>
<li>indexOf和contains以及lastIndexOf方法都是直接进行遍历，因为数组是无序的，也没办法采用二分法之类的进行快速查找。所以尽可能不要直接使用List的查找方法。</li>
<li>size方法成本不高，并不是每次都进行统计，而是内部存储了一个size变量，每次增删操作回进行更新。</li>
<li>暂时想到的就这么多，以后想起来再补充。</li>
</ul>
<h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h3><p>这个可是个老古董了，从JDK1.0开始就存在了（别问我怎么知道的，那会我也没用过Java，是文档自己写的。。。。），正因为是老古董，所以现在已经不是很推荐使用了，原因就是效率很低下，因为很多方法都暴力的增加了synchronized关键字，性能很低下。做个简单总结吧：</p>
<ul>
<li>因为很多方法都加上了synchronized关键词，导致整体性能较差，不推荐使用</li>
<li>底层实现也是数组，特性和ArrayList差不多。</li>
<li>注意：Vector没有实现Serializable接口</li>
<li>关于扩容：ArrayList每次扩容是1.5倍，Vector是2倍。代码如下：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private void grow(int minCapacity) &#123;</span><br><span class="line">    // overflow-conscious code</span><br><span class="line">    int oldCapacity = elementData.length;</span><br><span class="line">    int newCapacity = oldCapacity + ((capacityIncrement &gt; 0) ?</span><br><span class="line">                                     capacityIncrement : oldCapacity);//扩充一倍</span><br><span class="line">    if (newCapacity - minCapacity &lt; 0)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
capacityIncrement是构造方法传进来的，如果不指定，则传0。</li>
</ul>
<h3 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h3><p>这个类已经快被遗忘了，简单概述一下。</p>
<ul>
<li>1.0时代的远古产物，继承了Vector，所以也是各种synchronized关键字，性能低下</li>
<li>官方注释已经不推荐使用了，同样的功能可以使用Deque实现<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;Integer&gt; stack = new ArrayDeque&lt;Integer&gt;();</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><p>你以为LinkedList仅仅是一个链表实现的List的么？？那你就是图样图森破了，来看看强大的LinkedList吧。</p>
<ul>
<li>看一下接口层面：List、deque和Queue，也就是说LinkedList不仅仅是一个list集合，同时也是一个双向队列，当然也可以作为单向队列来使用。所以根据场景，上面的Stack也可以使用LinkedList进行替换</li>
<li>底层的实现是基于链表，基本存储数据的元素是Node，代码如下：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private static class Node&lt;E&gt; &#123;</span><br><span class="line">        E item;</span><br><span class="line">        Node&lt;E&gt; next;</span><br><span class="line">        Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">        Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">            this.item = element;</span><br><span class="line">            this.next = next;</span><br><span class="line">            this.prev = prev;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li>正是因为基于链表实现，所以理论上在任意位置进行增删操作都是O(1)的时间复杂度，但是为什么我说是理论上呢？因为实际进行增删的时候，必须要先找到对应的位置吧？这个查找的过程时间复杂度可就是O(n)了。</li>
<li>LinkedList同样没有加任何同步措施，因此也是线程不安全的。</li>
<li>说一个坑点：千万不要在for循环中通过索引的方式去获取元素（之前实习生干了这个事。。。），因为链表的<strong>通过索引方式进行随机读取的时间复杂度是O(n)</strong>!</li>
</ul>
<h3 id="简单汇总一下"><a href="#简单汇总一下" class="headerlink" title="简单汇总一下"></a>简单汇总一下</h3><table>
<thead>
<tr>
<th>列</th>
<th>ArrayList</th>
<th>LinkedList</th>
<th>Vector</th>
<th>Stack</th>
</tr>
</thead>
<tbody><tr>
<td>实现方式</td>
<td>数组</td>
<td>链表</td>
<td>数组</td>
<td>数组</td>
</tr>
<tr>
<td>线程安全</td>
<td>否</td>
<td>否</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>优势</td>
<td>适合随机读，末尾写</td>
<td>适合随机写，顺序读</td>
<td>线程安全</td>
<td>线程安全</td>
</tr>
<tr>
<td>劣势</td>
<td>不适合随机写入</td>
<td>不适合随机读取</td>
<td>性能差</td>
<td>性能差</td>
</tr>
<tr>
<td>扩容</td>
<td>1.5</td>
<td>-</td>
<td>2</td>
<td>-</td>
</tr>
</tbody></table>
<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>上面简单总结了一下List相关实现，接下来看看狐假虎威的Set。为啥说Set是狐假虎威呢？看看对应的实现类就明白了，基本上都是Map套了个壳（Map稍后总结）</p>
<h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><p>基于Hash实现的Set，内层实现是HashMap，所有的操作都是HashMap的Key的操作，而Map的实际Value则是一个Object对象。总结一下特点：</p>
<ul>
<li>判断是否存在速度很快，基于Hash实现如果不出现冲突，基本都是O(1)的操作。</li>
<li>线程不安全，需要自己实现线程同步方式</li>
<li>元素唯一（前提重写HashCode和equals方法,只有两者都相同才被认为是同一个元素）</li>
<li>不保证顺序，因为基于Hash实现，无法保证读取时候的顺序(也就是通过迭代器方式读取无法保证顺序，不过貌似重写HashCode之后，可以在一定程度上控制顺序，但是最好不要这么用。。)</li>
<li>因为底层实现是HashSet，所以也存在初始容量和负载因子，因此使用的时候如果事先知道存储大小，最好指定一下大小和负载因子，减少扩容消耗。</li>
<li>因为HashSet支持null作为key，所以HashSet也可以存储null元素</li>
</ul>
<h3 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h3><p>LinkedHashSet也是一个壳，继承了HashSet，注意一下HashSet内部还有一个带有boolean的构造方法，调用这种构造方法，则内部实现不再是HashMap，而是LinkedHashMap。</p>
<ul>
<li>LinkedHashSet和HashSet最大的区别就是能保证元素插入的顺序和通过迭代器读取的顺序是一致的(但是不是经过排序的，是保留插入的顺序)。</li>
<li>除了有序这个之外，其他特点和HashSet一样，因为继承了嘛(写这个类的人，真的是懒到极致的。。向他学习！)</li>
</ul>
<h3 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h3><p>看到TreeSet是不是立即想到了TreeMap？对的，TreeSet内部就是一个NavigableMap，NavigableMap又是什么？java.util包下原生的实现且暴露出来的好像只有。。。。TreeMap。。。</p>
<ul>
<li>内部实现是TreeMap，也就是基于红黑树（啥是红黑树？。。。自行百度。。）,所以整体操作复杂度事O(log(n)),表面上看不如HashSet的O(1)速度快，但是一旦出现大量Hash冲突的时候，HashSet性能将急剧下降，因为冲突导致查询变为链表遍历(好像1.8还是1.7开始，冲突元素个数增加到8就会进行树化，防止链表过长)，而TreeSet不会存在这个问题。</li>
<li>TreeSet实现了NavigableSet接口和SortedSet接口，也就是说TreeSet中的元素是有序的，同时是支持范围查询,查找大于或者小于某个元素的元素或者集合(具体看NavigableSet接口)，这些都是HashSet无法提供的。</li>
<li>线程不安全，补充：因为红黑树实现复杂，并发粒度控制困难(应该是这个原因)，官方没有提供TreeSet对应的并发类，而是提供了基于跳表实现的并发类(后面再说)</li>
<li>其他想到了再补充。。</li>
</ul>
<h3 id="EnumSet"><a href="#EnumSet" class="headerlink" title="EnumSet"></a>EnumSet</h3><p>EnumSet是一个抽象类，有两个实现：</p>
<ul>
<li>RegularEnumSet</li>
<li>JumboEnumSet</li>
</ul>
<p>注意一下，这两个类都是不对外暴露的，对外统一暴露的是EnumSet。这两个类有啥区别呢？RegularEnumSet存储的是元素个数小于等于64个，JumboEnumSet则是超过64个。<br>为啥要单独出来一个EnumSet呢？HashSet，TreeSet也是可以存储枚举的啊，查了一堆资料(实际上我也没用过这玩意。。)，总结如下：</p>
<ul>
<li>EnumSet的速度很快，原因是底层用了elements进行位运算，也就是说EnumSet并不直接存放枚举对象，而是存储一个对应类和elements，通过位运算来判断Set中有哪些元素，速度自然要快得多。</li>
<li>一旦元素的枚举类型确定那么集合就确定了（因为要通过枚举类型进行位判断，如果更换了枚举类型，会导致结果出错，所以不允许修改）</li>
<li>EnumSet只能存放一种枚举类型的元素(原因同上)</li>
</ul>
<h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h2><p>一个先入先出的数据结构，util包下实现好像只有下面3个，这个主要在juc包下实现类较多(各种阻塞队列)</p>
<h3 id="LinkedList-1"><a href="#LinkedList-1" class="headerlink" title="LinkedList"></a>LinkedList</h3><p>前面已经说过，不再多说了。</p>
<h3 id="ArrayDeque"><a href="#ArrayDeque" class="headerlink" title="ArrayDeque"></a>ArrayDeque</h3><p>和LinkedList相比，最大不同就是底层实现是依赖于一个数组,简单汇总一下其特点:</p>
<ul>
<li>实现依赖于一个循环数组</li>
<li>扩容: 扩容直接将容量翻倍，然后执行数组拷贝</li>
<li>容量：要求必须是2的幂次方(方便进行位移运算)</li>
<li>优势：和LinkedList相比，无需用Node对数据进行包裹，而且数组通过下标访问速度很快</li>
<li>应用场景:额。。。其实我也没怎么用过，感觉常用栈和队列都可以用这个实现(好吧，以前我都是用LinkedList实现栈的操作。。。)</li>
</ul>
<h3 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h3><p>这个感觉平时用的也很少，是一个带有优先级的队列(并发包中的优先队列貌似使用场景更多一些。。)，这个研究不多，直接当个搬运工吧(参考:<a target="_blank" rel="noopener" href="https://www.cnblogs.com/mfrank/p/9614520.html">https://www.cnblogs.com/mfrank/p/9614520.html</a>)</p>
<ul>
<li>内部是根据小顶堆的结构进行存储的</li>
<li>构造方法需要传入一个比较器，用于判断优先级</li>
<li>内部实际上也是使用一个数组进行数据存储，同时有一个heapify()方法，用于将数组进行堆化(具体过程就不描述了。。。)</li>
<li>应用场景，基本上就是堆的应用场景，比如寻找topN之类的</li>
</ul>
<h1 id="顺便肯一下另外一组容器"><a href="#顺便肯一下另外一组容器" class="headerlink" title="顺便肯一下另外一组容器"></a>顺便肯一下另外一组容器</h1><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>Map我的理解就是存储键值对的容器，基本上每一种开发语言都有这种容器，比如Python,C#的字典，golang的map，应该说Map是和数组一个级别的重要容器了。最常用的应该是基于Hash实现的HashMap，当然还有基于红黑树的TreeMap。先看一下Map相关的类图：<br><img src="/Java%E9%9B%86%E5%90%88%E7%B1%BB/Map.png" alt="Java集合类"><br>简单总结一下：</p>
<h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p>最常用的Map，没有之一(至少我工作这两年看到的Map，九成以上都是HashMap)，应该也是面试必问容器，后面估计要专门整理一篇HashMap的总结了(网上各种总结已经一大把了。。)，简单总结一下特点：</p>
<ul>
<li>基于hash的方法，能够快速通过key找到对应的value</li>
<li>内部存储数据是基于数组，Node&lt;K,V&gt;[] table;</li>
<li>线程不安全(几乎面试都会问到，然后就自然转到了juc的并发包了)</li>
<li>Key建议使用字符串，当然用自定义对象也可以，但是要重写hashcode和equals方法，否则不保证正确性了。</li>
<li>hash冲突的解决是通过链表方式，链表长度超过8以后，转为红黑树，当长度减少到6一下，再次转换为链表。(原因是怕链表长度过长，导致查询速度过慢，而冲突变少之后使用链表和树速度差别小，但是复杂度来看，链表要简单。。好吧，也是强行解释)</li>
<li>迭代遍历不保证顺序</li>
<li>允许null作为key和value</li>
</ul>
<h3 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a>Hashtable</h3><p>远古产物，并且类命名还不对，正确命名应该是HashTable，估计是当时开发人员粗心，写成了Hashtable，然后为了兼容性，那就错着把。。。功能上和HashMap基本一样，简单总结一下:</p>
<ul>
<li>线程安全，但是性能低下，全部基于synchronized关键词实现。</li>
<li>不允许null作为key和value</li>
</ul>
<h3 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h3><ul>
<li>与HashMap相比，保留的key的插入顺序性，遍历的时候和插入的顺序一致</li>
<li>原理是内部维护了一条双向链表，记录插入的顺序</li>
<li>额外增加了空间和时间上的开销</li>
<li>应用场景<ul>
<li>保留插入顺序的遍历场景</li>
<li>LRU缓存的实现(可以看一下MyBatis的缓存实现，其中就有基于LinkedHashMap的LRU缓存)</li>
</ul>
</li>
</ul>
<h3 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h3><p>这个因为红黑树实现，有点复杂(面试在单独复习红黑树吧。。)，所以就不管内部具体实现了，总结一下特点</p>
<ul>
<li>线程不安全，即使是在并发包中也没有TreeMap的并发类</li>
<li>实现了SortedMap接口，说明Key是有序的</li>
<li>遍历的时候根据Key的自然顺序进行，或者指定Comparator比较器</li>
<li>实现了NavigableMap接口，也就是说支持区间范围或者比大小操作(基于Key的)</li>
<li>整体操作复杂度均为O(log(n))</li>
</ul>
<h3 id="EnumMap"><a href="#EnumMap" class="headerlink" title="EnumMap"></a>EnumMap</h3><p>针对枚举类作为Key的情形进行优化的Map，内部通过数组存储，查找的时候直接通过枚举的ordinal作为index快速查询。</p>
<ul>
<li>只能支持单一类型枚举</li>
</ul>
<h3 id="IdentityHashMap"><a href="#IdentityHashMap" class="headerlink" title="IdentityHashMap"></a>IdentityHashMap</h3><p>陌生么？陌生。。。陌生就对了，因为日常开发中，压根就不会用到这玩意。。这玩意干嘛用的，它实际上是严格版本的HashMap，有多严格？引用必须相等！  </p>
<p>HashMap中判断key相等的依据是key.equals(otherKey),而IdentityHashMap判断key相等的依据是key&#x3D;&#x3D;otherKey，这种严格的限制，恕我无知。。我实在是找不到应用场景。。关键这个类还是大神Doug Lea写的。。。大神的思维。。不懂。。不懂。。</p>
<h3 id="WeakHashMap"><a href="#WeakHashMap" class="headerlink" title="WeakHashMap"></a>WeakHashMap</h3><p>这个容器使用之前最好先了解一下Java中的引用(强软弱虚)，WeakHashMap是一种弱key实现的容器，使用场景主要还是缓存吧(反正我没用过。。。)，说一下特点</p>
<ul>
<li>当key被GC回收后，对应Map中的KeyValue対也会被回收，附代码示例:<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">    WeakHashMap&lt;String, Object&gt; map = new WeakHashMap&lt;&gt;();</span><br><span class="line">    String k1 = new String(&quot;k1&quot;); //注意一定要使用new String(&quot;xxx&quot;)，形式</span><br><span class="line">    String k2 = new String(&quot;k2&quot;);</span><br><span class="line">    String k3 = new String(&quot;k3&quot;);</span><br><span class="line">    map.put(k1,new Object());</span><br><span class="line">    map.put(k2,new Object());</span><br><span class="line">    map.put(k3,new Object());</span><br><span class="line">    System.out.println(map);</span><br><span class="line">    System.gc();</span><br><span class="line">    Thread.sleep(500);</span><br><span class="line">    System.out.println(map);</span><br><span class="line">    k1 = null;</span><br><span class="line">    k2 = null;</span><br><span class="line">    k3 = null;</span><br><span class="line">    System.out.println(&quot;Key=null -&gt; &quot; +map);</span><br><span class="line">    System.gc();</span><br><span class="line">    Thread.sleep(500);</span><br><span class="line">    System.out.println(&quot;After GC -&gt; &quot; +map);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h3><p>以前我还真不知道Properties竟然也是Map的实现类，内部主要是各种读取配置文件相关逻辑，存储方面由于继承了Hashtable，所以也是线程安全的，关于这个就不分析啥了。。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>糊里糊涂整理了一下java.util包下面的集合相关类(容器类也行。。)，发现了几个平时开发中没用过的容器，但是其实是都可以用的。。。比如ArrayDeque，比如Enum相关Set和Map(恕我无知，之前真的都是通过HashSet和HashMap实现的。。。)。等后续有时间了，整理一下并发包下面的容器（好像已经烂大街了。。。）</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://eviltuzki.top/2019/06/23/CompletableFuture%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Eviltuzki">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eviltuzki">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/06/23/CompletableFuture%E5%AD%A6%E4%B9%A0%E6%B1%87%E6%80%BB/" class="post-title-link" itemprop="url">CompletableFuture 学习汇总</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-06-23 00:00:00" itemprop="dateCreated datePublished" datetime="2019-06-23T00:00:00+08:00">2019-06-23</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="static方法"><a href="#static方法" class="headerlink" title="static方法"></a>static方法</h3><h4 id="public-static-CompletableFuture-supplyAsync-Supplier-supplier"><a href="#public-static-CompletableFuture-supplyAsync-Supplier-supplier" class="headerlink" title="public static  CompletableFuture supplyAsync(Supplier supplier)"></a>public static <U> CompletableFuture<U> supplyAsync(Supplier<U> supplier)</h4><ul>
<li>提交一个Supplier任务，异步执行，可以获取任务返回结果，使用ForkJoinPool.commonPool()执行任务。</li>
</ul>
<h4 id="public-static-CompletableFuture-supplyAsync-Supplier-supplier-Executor-executor"><a href="#public-static-CompletableFuture-supplyAsync-Supplier-supplier-Executor-executor" class="headerlink" title="public static  CompletableFuture supplyAsync(Supplier supplier, Executor executor)"></a>public static <U> CompletableFuture<U> supplyAsync(Supplier<U> supplier, Executor executor)</h4><ul>
<li>提交一个Supplier任务，异步执行，可以获取任务返回结果，使用指定的线程池执行</li>
</ul>
<h4 id="public-static-CompletableFuture-runAsync-Runnable-runnable"><a href="#public-static-CompletableFuture-runAsync-Runnable-runnable" class="headerlink" title="public static CompletableFuture runAsync(Runnable runnable)"></a>public static CompletableFuture<Void> runAsync(Runnable runnable)</h4><ul>
<li>提交一个Runnable任务，异步执行，无返回结果，使用ForkJoinPool.commonPool()执行任务。</li>
</ul>
<h4 id="public-static-CompletableFuture-runAsync-Runnable-runnable-Executor-executor"><a href="#public-static-CompletableFuture-runAsync-Runnable-runnable-Executor-executor" class="headerlink" title="public static CompletableFuture runAsync(Runnable runnable, Executor executor)"></a>public static CompletableFuture<Void> runAsync(Runnable runnable, Executor executor)</h4><ul>
<li>提交一个Supplier任务，异步执行，无返回结果，使用指定的线程池执行</li>
</ul>
<h4 id="public-static-CompletableFuture-completedFuture-U-value"><a href="#public-static-CompletableFuture-completedFuture-U-value" class="headerlink" title="public static  CompletableFuture completedFuture(U value)"></a>public static <U> CompletableFuture<U> completedFuture(U value)</h4><ul>
<li>新建一个完成的CompletableFuture，通常作为计算的起点阶段。</li>
</ul>
<h4 id="public-static-CompletableFuture-allOf-CompletableFuture-lt-gt-…-cfs"><a href="#public-static-CompletableFuture-allOf-CompletableFuture-lt-gt-…-cfs" class="headerlink" title="public static CompletableFuture allOf(CompletableFuture&lt;?&gt;… cfs)"></a>public static CompletableFuture<Void> allOf(CompletableFuture&lt;?&gt;… cfs)</h4><ul>
<li>接收一个由CompletableFuture 构成的数组，需要等待多个 CompletableFuture 对象执行完毕，执行join操作可以等待CompletableFuture执行完成。</li>
</ul>
<h4 id="public-static-CompletableFuture-anyOf-CompletableFuture-lt-gt-…-cfs"><a href="#public-static-CompletableFuture-anyOf-CompletableFuture-lt-gt-…-cfs" class="headerlink" title="public static CompletableFuture anyOf(CompletableFuture&lt;?&gt;… cfs)"></a>public static CompletableFuture<Object> anyOf(CompletableFuture&lt;?&gt;… cfs)</h4><ul>
<li>接收一个由CompletableFuture 构成的数组，返回由第一个执行完毕的 CompletableFuture 对象的返回值构成的CompletableFuture<Object> 。</li>
</ul>
<h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">import java.text.SimpleDateFormat;</span><br><span class="line">import java.util.Date;</span><br><span class="line">import java.util.concurrent.CompletableFuture;</span><br><span class="line">import java.util.concurrent.ExecutionException;</span><br><span class="line">import java.util.concurrent.ExecutorService;</span><br><span class="line">import java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line">public class ThreadTest1 &#123;</span><br><span class="line">    private static SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss.SSS&quot;);</span><br><span class="line">    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;</span><br><span class="line">        ExecutorService pool = Executors.newFixedThreadPool(4);</span><br><span class="line">        //创建一个直接完成的CompletableFuture</span><br><span class="line">        String now = CompletableFuture.completedFuture(&quot;Test&quot;)</span><br><span class="line">                .getNow(&quot;Fail&quot;);</span><br><span class="line">        println(&quot;completedFuture: &quot; + now);</span><br><span class="line">        //创建一个带有返回值的CompletableFuture</span><br><span class="line">        CompletableFuture&lt;String&gt; task = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            sleep(100);</span><br><span class="line">            return &quot;Test&quot;;</span><br><span class="line">        &#125;, pool);</span><br><span class="line">        //延迟100ms，这里获取是default值</span><br><span class="line">        now = task.getNow(&quot;Fail&quot;);</span><br><span class="line">        println(&quot;supplyAsync: now: &quot; + now);</span><br><span class="line">        //等待任务完成后输出</span><br><span class="line">        println(&quot;supplyAsync: get: &quot; + task.get());</span><br><span class="line">        System.out.println(&quot;---------------------分割线----------------------&quot;);</span><br><span class="line">        //耗时100ms的任务</span><br><span class="line">        CompletableFuture&lt;Void&gt; task100 = CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">            sleep(100);</span><br><span class="line">            println(&quot;runAsync :&quot; + Thread.currentThread().getName() + &quot; task100 done&quot;);</span><br><span class="line">        &#125;, pool);</span><br><span class="line">        //耗时200ms的任务</span><br><span class="line">        CompletableFuture&lt;Void&gt; task200 = CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">            sleep(200);</span><br><span class="line">            println(&quot;runAsync :&quot; + Thread.currentThread().getName() + &quot; task200 done&quot;);</span><br><span class="line">        &#125;, pool);</span><br><span class="line">        //任意一个完成就会继续执行</span><br><span class="line">        CompletableFuture.anyOf(task100, task200).join();</span><br><span class="line">        println(&quot;anyOf Done&quot;);</span><br><span class="line">        //全部完成才会继续执行</span><br><span class="line">        CompletableFuture.allOf(task100, task200).join();</span><br><span class="line">        println(&quot;allOf Done&quot;);</span><br><span class="line">        //关闭线程池</span><br><span class="line">        pool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void sleep(long time) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(time);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    private static void println(Object object)&#123;</span><br><span class="line">        System.out.println(sdf.format(new Date()) + &quot;: &quot; + object);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">2019-06-23 18:02:03.552: completedFuture: Test</span><br><span class="line">2019-06-23 18:02:03.604: supplyAsync: now: Fail</span><br><span class="line">2019-06-23 18:02:03.710: supplyAsync: get: Test</span><br><span class="line">-------------------------------------------</span><br><span class="line">2019-06-23 18:02:03.813: runAsync :pool-1-thread-2 task100 done</span><br><span class="line">2019-06-23 18:02:03.813: anyOf Done</span><br><span class="line">2019-06-23 18:02:04.012: runAsync :pool-1-thread-3 task200 done</span><br><span class="line">2019-06-23 18:02:04.012: allOf Done</span><br></pre></td></tr></table></figure>

<h3 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h3><ul>
<li>实例方法整体比较规则，一个标准执行方法，一个异步执行方法，一个指定异步线程执行方法</li>
</ul>
<h4 id="thenApply"><a href="#thenApply" class="headerlink" title="thenApply"></a>thenApply</h4><ul>
<li>then是指在当前阶段正常执行完成后（正常执行是指没有抛出异常）进行的操作。Apply是指将一个Function作用于之前阶段得出的结果(即将上一步的结果进行转换)</li>
<li>public <U> CompletableFuture<U> (Function&lt;? super T,? extends U&gt; fn)</li>
<li>public <U> CompletableFuture<U> thenApplyAsync(Function&lt;? super T,? extends U&gt; fn)</li>
<li>public <U> CompletableFuture<U> thenApplyAsync(Function&lt;? super T,? extends U&gt; fn, Executor executor) <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static void thenApplyAsyncDemo()&#123;</span><br><span class="line">    Integer integer = CompletableFuture</span><br><span class="line">            .completedFuture(&quot;task 1&quot;)</span><br><span class="line">            .thenApplyAsync(x -&gt; &#123;</span><br><span class="line">                String intString = x.split(&quot; &quot;)[1];</span><br><span class="line">                return Integer.valueOf(intString);</span><br><span class="line">            &#125;)</span><br><span class="line">            .join();</span><br><span class="line">    System.out.println(&quot;thenApplyAsyncDemo: &quot; + integer);</span><br><span class="line">&#125;</span><br><span class="line">--------- 输出 -----------</span><br><span class="line">thenApplyAsyncDemo: 1    </span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="thenAccept"><a href="#thenAccept" class="headerlink" title="thenAccept"></a>thenAccept</h4><ul>
<li>下一个Stage接收了当前Stage的结果但是在计算中无需返回值(可以简单认为这里就是消费终点，因为没有返回值。当然下一步不依赖当前返回值的情况除外)</li>
<li>public CompletableFuture<Void> thenAccept(Consumer&lt;? super T&gt; action)</li>
<li>public CompletableFuture<Void> thenAcceptAsync(Consumer&lt;? super T&gt; action)</li>
<li>public CompletableFuture<Void> thenAcceptAsync(Consumer&lt;? super T&gt; action,Executor executor)<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static void thenAcceptDemo()&#123;</span><br><span class="line">    CompletableFuture</span><br><span class="line">            .completedFuture(&quot;task&quot;)</span><br><span class="line">            .thenAcceptAsync(s -&gt; &#123;</span><br><span class="line">                System.out.println(&quot;thenAcceptDemo：&quot; + s);</span><br><span class="line">            &#125;)</span><br><span class="line">            .join();</span><br><span class="line">&#125;</span><br><span class="line">--------- 输出 -----------</span><br><span class="line">thenAcceptDemo：task</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="thenRun"><a href="#thenRun" class="headerlink" title="thenRun"></a>thenRun</h4><ul>
<li>不再关心上一步运算的结果，直接进行下一步的运算</li>
<li>public CompletableFuture<Void> thenRun(Runnable action)</li>
<li>public CompletableFuture<Void> thenRunAsync(Runnable action)</li>
<li>public CompletableFuture<Void> thenRunAsync(Runnable action, Executor executor)<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void thenRunDemo() &#123;</span><br><span class="line">    CompletableFuture.completedFuture(&quot;Task&quot;)</span><br><span class="line">            .thenRun(() -&gt; System.out.println(&quot;我不知道上面的参数，也不会继续往下传递值&quot;))</span><br><span class="line">            .join();</span><br><span class="line">&#125;</span><br><span class="line">--------- 输出 -----------</span><br><span class="line">我不知道上面的参数，也不会继续往下传递值</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="thenCombine"><a href="#thenCombine" class="headerlink" title="thenCombine"></a>thenCombine</h4><ul>
<li>结合前面两个Stage的结果，进行转化</li>
<li>public &lt;U,V&gt; CompletableFuture<V> thenCombine(CompletionStage&lt;? extends U&gt; other, BiFunction&lt;? super T,? super U,? extends V&gt; fn)</li>
<li>public &lt;U,V&gt; CompletableFuture<V> thenCombineAsync(CompletionStage&lt;? extends U&gt; other,BiFunction&lt;? super T,? super U,? extends V&gt; fn) </li>
<li>public &lt;U,V&gt; CompletableFuture<V> thenCombineAsync(CompletionStage&lt;? extends U&gt; other,BiFunction&lt;? super T,? super U,? extends V&gt; fn, Executor executor)<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static void thenCombineDemo() &#123;</span><br><span class="line">    CompletableFuture&lt;String&gt; task1 = CompletableFuture.supplyAsync(() -&gt; &quot;task 1&quot;);</span><br><span class="line">    CompletableFuture&lt;String&gt; task2 = CompletableFuture.supplyAsync(() -&gt; &quot;task 2&quot;);</span><br><span class="line">    String result = task1.thenCombineAsync(task2, (t1, t2) -&gt; t1 + &quot; - &quot;+ t2)</span><br><span class="line">            .join();</span><br><span class="line">    System.out.println(result);</span><br><span class="line">&#125;</span><br><span class="line">--------- 输出 -----------</span><br><span class="line">task 1 - task 2</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="thenAcceptBoth"><a href="#thenAcceptBoth" class="headerlink" title="thenAcceptBoth"></a>thenAcceptBoth</h4><ul>
<li>结合两个CompletionStage的结果，进行消耗,和thenCombine相比，只是少了返回值</li>
<li>public <U> CompletableFuture<Void> thenAcceptBoth(CompletionStage&lt;? extends U&gt; other,BiConsumer&lt;? super T, ? super U&gt; action)</li>
<li>public <U> CompletableFuture<Void> thenAcceptBothAsync(CompletionStage&lt;? extends U&gt; other,BiConsumer&lt;? super T, ? super U&gt; action) </li>
<li>public <U> CompletableFuture<Void> thenAcceptBothAsync(CompletionStage&lt;? extends U&gt; other,BiConsumer&lt;? super T, ? super U&gt; action, Executor executor) <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static void thenAcceptBothDemo() &#123;</span><br><span class="line">    CompletableFuture&lt;String&gt; task1 = CompletableFuture.supplyAsync(() -&gt; &quot;task 1&quot;);</span><br><span class="line">    CompletableFuture&lt;String&gt; task2 = CompletableFuture.supplyAsync(() -&gt; &quot;task 2&quot;);</span><br><span class="line">    task1.thenAcceptBoth(task2, (t1, t2) -&gt; System.out.println(&quot;thenAcceptBothDemo: &quot; +t1 + &quot; - &quot; + t2))</span><br><span class="line">            .join();</span><br><span class="line">&#125;</span><br><span class="line">--------- 输出 -----------</span><br><span class="line">thenAcceptBothDemo: task 1 - task 2</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="runAfterBoth"><a href="#runAfterBoth" class="headerlink" title="runAfterBoth"></a>runAfterBoth</h4><ul>
<li>在两个CompletionStage都运行完执行。</li>
<li>public CompletableFuture<Void> runAfterBoth(CompletionStage&lt;?&gt; other,Runnable action)</li>
<li>public CompletableFuture<Void> runAfterBothAsync(CompletionStage&lt;?&gt; other,Runnable action) </li>
<li>public CompletableFuture<Void> runAfterBothAsync(CompletionStage&lt;?&gt; other,Runnable action,Executor executor) <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public static void runAfterBothDemo() &#123;</span><br><span class="line">    CompletableFuture&lt;Void&gt; task1 = CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">        sleep(100);</span><br><span class="line">        println(&quot;task1 Done&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    CompletableFuture&lt;Void&gt; task2 = CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">        sleep(200);</span><br><span class="line">        println(&quot;task2 Done&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    task1.runAfterBoth(task2, () -&gt; println(&quot;Task 1 And Task 2 Both Done&quot;))</span><br><span class="line">            .join();</span><br><span class="line">&#125;</span><br><span class="line">--------- 输出 -----------</span><br><span class="line">2019-06-23 19:22:08.498: task1 Done</span><br><span class="line">2019-06-23 19:22:08.595: task2 Done</span><br><span class="line">2019-06-23 19:22:08.596: Task 1 And Task 2 Both Done</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="applyToEither"><a href="#applyToEither" class="headerlink" title="applyToEither"></a>applyToEither</h4><ul>
<li>在两个CompletionStage中选择计算快的，将其结果进行下一步的转化操作。</li>
<li>public <U> CompletableFuture<U> applyToEither(CompletionStage&lt;? extends T&gt; other, Function&lt;? super T, U&gt; fn)</li>
<li>public <U> CompletableFuture<U> applyToEitherAsync(CompletionStage&lt;? extends T&gt; other, Function&lt;? super T, U&gt; fn) </li>
<li>public <U> CompletableFuture<U> applyToEitherAsync(CompletionStage&lt;? extends T&gt; other, Function&lt;? super T, U&gt; fn,Executor executor) <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static void applyToEitherDemo() &#123;</span><br><span class="line">    CompletableFuture&lt;String&gt; task1 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        sleep(10);</span><br><span class="line">        return &quot;task 1&quot;;</span><br><span class="line">    &#125;);</span><br><span class="line">    CompletableFuture&lt;String&gt; task2 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        sleep(20);</span><br><span class="line">        return &quot;task 2&quot;;</span><br><span class="line">    &#125;);</span><br><span class="line">    Integer result = task1.applyToEither(task2, t -&gt; Integer.valueOf(t.split(&quot; &quot;)[1]))</span><br><span class="line">            .join();</span><br><span class="line">    System.out.println(&quot;applyToEitherDemo:&quot; + result);</span><br><span class="line">&#125;</span><br><span class="line">--------- 输出 -----------</span><br><span class="line">applyToEitherDemo:1</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="acceptEither"><a href="#acceptEither" class="headerlink" title="acceptEither"></a>acceptEither</h4><ul>
<li>在两个CompletionStage中选择计算快的，作为下一步计算的结果。</li>
<li>public CompletableFuture<Void> acceptEither(CompletionStage&lt;? extends T&gt; other, Consumer&lt;? super T&gt; action) </li>
<li>public CompletableFuture<Void> acceptEitherAsync(CompletionStage&lt;? extends T&gt; other, Consumer&lt;? super T&gt; action)</li>
<li>public CompletableFuture<Void> acceptEitherAsync(CompletionStage&lt;? extends T&gt; other, Consumer&lt;? super T&gt; action,Executor executor)<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public static void acceptEitherDemo() &#123;</span><br><span class="line">    CompletableFuture&lt;String&gt; task1 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        sleep(10);</span><br><span class="line">        return &quot;task 1&quot;;</span><br><span class="line">    &#125;);</span><br><span class="line">    CompletableFuture&lt;String&gt; task2 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        sleep(20);</span><br><span class="line">        return &quot;task 2&quot;;</span><br><span class="line">    &#125;);</span><br><span class="line">    task1.acceptEitherAsync(task2, t -&gt; System.out.println(&quot;acceptEitherDemo:&quot; +Integer.valueOf(t.split(&quot; &quot;)[1])))</span><br><span class="line">            .join();</span><br><span class="line">&#125;</span><br><span class="line">--------- 输出 -----------</span><br><span class="line">acceptEitherDemo:1</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="runAfterEither"><a href="#runAfterEither" class="headerlink" title="runAfterEither"></a>runAfterEither</h4><ul>
<li>两个CompletionStage，任何一个完成了都会执行下一步的操作。</li>
<li>public CompletableFuture<Void> runAfterEither(CompletionStage&lt;?&gt; other,Runnable action) </li>
<li>public CompletableFuture<Void> runAfterEitherAsync(CompletionStage&lt;?&gt; other,Runnable action) </li>
<li>public CompletableFuture<Void> runAfterEitherAsync(CompletionStage&lt;?&gt; other,Runnable action,Executor executor) <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public static void runAfterEitherDemo() &#123;</span><br><span class="line">    CompletableFuture&lt;Void&gt; task1 = CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">        sleep(100);</span><br><span class="line">        println(&quot;task1 Done&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    CompletableFuture&lt;Void&gt; task2 = CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">        sleep(200);</span><br><span class="line">        println(&quot;task2 Done&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    task1.runAfterEither(task2, () -&gt; println(&quot;Task 1 Or Task 2 Done&quot;))</span><br><span class="line">            .join();</span><br><span class="line">    sleep(100);</span><br><span class="line">&#125;</span><br><span class="line">--------- 输出 -----------</span><br><span class="line">2019-06-23 19:24:27.644: task1 Done</span><br><span class="line">2019-06-23 19:24:27.645: Task 1 Or Task 2 Done</span><br><span class="line">2019-06-23 19:24:27.749: task2 Done</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="thenCompose"><a href="#thenCompose" class="headerlink" title="thenCompose"></a>thenCompose</h4><ul>
<li>连接两个CompletableFuture，返回值是新的CompletableFuture</li>
<li>public <U> CompletableFuture<U> thenCompose(Function&lt;? super T, ? extends CompletionStage<U>&gt; fn) </li>
<li>public <U> CompletableFuture<U> thenComposeAsync(Function&lt;? super T, ? extends CompletionStage<U>&gt; fn) </li>
<li>public <U> CompletableFuture<U> thenComposeAsync(Function&lt;? super T, ? extends CompletionStage<U>&gt; fn,Executor executor)<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static void thenComposeDemo() &#123;</span><br><span class="line">    String result = CompletableFuture.completedFuture(&quot;Start&quot;)</span><br><span class="line">            .thenCompose(x -&gt; CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">                sleep(20);</span><br><span class="line">                return x + &quot; task 2&quot;;</span><br><span class="line">            &#125;))</span><br><span class="line">            .thenCompose(x -&gt; CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">                sleep(10);</span><br><span class="line">                return x + &quot; task 1&quot;;</span><br><span class="line">            &#125;))</span><br><span class="line">            .join();</span><br><span class="line">    System.out.println(&quot;thenComposeDemo:&quot; +result);</span><br><span class="line">&#125;</span><br><span class="line">--------- 输出 -----------</span><br><span class="line">thenComposeDemo:Start task 2 task 1</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="whenComplete"><a href="#whenComplete" class="headerlink" title="whenComplete"></a>whenComplete</h4><ul>
<li>当运行完成时，对结果的记录。<ul>
<li>正常执行，返回值。</li>
<li>异常抛出造成程序的中断</li>
</ul>
</li>
<li>注意，内部线程出现异常会抛到外层，导致外层线程产生异常。</li>
<li>public CompletableFuture<T> whenComplete(BiConsumer&lt;? super T, ? super Throwable&gt; action) </li>
<li>public CompletableFuture<T> whenCompleteAsync(BiConsumer&lt;? super T, ? super Throwable&gt; action)</li>
<li>public CompletableFuture<T> whenCompleteAsync(BiConsumer&lt;? super T, ? super Throwable&gt; action, Executor executor) <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public static void whenCompleteDemo() &#123;</span><br><span class="line">    CompletableFuture&lt;String&gt; task1 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        sleep(10);</span><br><span class="line">        return &quot;task 1&quot;;</span><br><span class="line">    &#125;);</span><br><span class="line">    CompletableFuture&lt;String&gt; task2 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        sleep(20);</span><br><span class="line">        throw new RuntimeException(&quot;task2 RuntimeException&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    String task1res = task1.whenComplete((res, exp) -&gt; &#123;</span><br><span class="line">        println(&quot;task1 res:&quot; + res);</span><br><span class="line">        println(&quot;task1 exp:&quot; + exp);</span><br><span class="line">    &#125;).join();</span><br><span class="line">    println(task1res);</span><br><span class="line">    String task2res = task2.whenComplete((res, exp) -&gt; &#123;</span><br><span class="line">        println(&quot;task2 res:&quot; + res);</span><br><span class="line">        println(&quot;task2 exp:&quot; + exp.getMessage());</span><br><span class="line">    &#125;).join();</span><br><span class="line">    println(task2res);</span><br><span class="line">&#125;</span><br><span class="line">--------- 输出 -----------</span><br><span class="line">2019-06-23 19:50:03.429 ForkJoinPool.commonPool-worker-1: task1 res:task 1</span><br><span class="line">2019-06-23 19:50:03.430 ForkJoinPool.commonPool-worker-1: task1 exp:null</span><br><span class="line">2019-06-23 19:50:03.430 main: task 1</span><br><span class="line">2019-06-23 19:50:03.439 ForkJoinPool.commonPool-worker-2: task2 res:null</span><br><span class="line">2019-06-23 19:50:03.439 ForkJoinPool.commonPool-worker-2: task2 exp:java.lang.RuntimeException: task2 RuntimeException</span><br><span class="line">Exception in thread &quot;main&quot; java.util.concurrent.CompletionException: java.lang.RuntimeException: task2 RuntimeException</span><br><span class="line">    at java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:273)</span><br><span class="line">    at java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:280)</span><br><span class="line">    at java.util.concurrent.CompletableFuture$AsyncSupply.run(CompletableFuture.java:1592)</span><br><span class="line">    at java.util.concurrent.CompletableFuture$AsyncSupply.exec(CompletableFuture.java:1582)</span><br><span class="line">    at java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:289)</span><br><span class="line">    at java.util.concurrent.ForkJoinPool$WorkQueue.runTask(ForkJoinPool.java:1056)</span><br><span class="line">    at java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1692)</span><br><span class="line">    at java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:157)</span><br><span class="line">Caused by: java.lang.RuntimeException: task2 RuntimeException</span><br><span class="line">    at com.example.demo.ThreadTest.lambda$whenCompleteDemo$5(ThreadTest.java:44)</span><br><span class="line">    at java.util.concurrent.CompletableFuture$AsyncSupply.run(CompletableFuture.java:1590)</span><br><span class="line">    ... 5 more</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="handle"><a href="#handle" class="headerlink" title="handle"></a>handle</h4><ul>
<li>运行完成时，对结果的处理。这里的完成时有两种情况，<ul>
<li>正常执行，返回值</li>
<li>遇到异常抛出造成程序的中断。</li>
</ul>
</li>
<li>异常不会被抛到外层，不会造成外部线程因为异常中断</li>
<li>public <U> CompletableFuture<U> handle(BiFunction&lt;? super T, Throwable, ? extends U&gt; fn) </li>
<li>public <U> CompletableFuture<U> handleAsync(BiFunction&lt;? super T, Throwable, ? extends U&gt; fn) </li>
<li>public <U> CompletableFuture<U> handleAsync(BiFunction&lt;? super T, Throwable, ? extends U&gt; fn, Executor executor) <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public static void handleDemo() &#123;</span><br><span class="line">    CompletableFuture&lt;String&gt; task1 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        sleep(10);</span><br><span class="line">        return &quot;task 1&quot;;</span><br><span class="line">    &#125;);</span><br><span class="line">    CompletableFuture&lt;String&gt; task2 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        sleep(20);</span><br><span class="line">        throw new RuntimeException(&quot;task2 RuntimeException&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    String task1res = task1.handle((res, exp) -&gt; &#123;</span><br><span class="line">        println(&quot;task1 res:&quot; + res);</span><br><span class="line">        println(&quot;task1 exp:&quot; + exp);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;).join();</span><br><span class="line">    println(task1res);</span><br><span class="line">    String task2res = task2.handle((res, exp) -&gt; &#123;</span><br><span class="line">        println(&quot;task2 res:&quot; + res);</span><br><span class="line">        println(&quot;task2 exp:&quot; + exp.getMessage());</span><br><span class="line">        return res;</span><br><span class="line">    &#125;).join();</span><br><span class="line">    println(task2res);</span><br><span class="line">&#125;</span><br><span class="line">--------- 输出 -----------</span><br><span class="line">2019-06-23 19:50:53.542 ForkJoinPool.commonPool-worker-1: task1 res:task 1</span><br><span class="line">2019-06-23 19:50:53.543 ForkJoinPool.commonPool-worker-1: task1 exp:null</span><br><span class="line">2019-06-23 19:50:53.543 main: task 1</span><br><span class="line">2019-06-23 19:50:53.552 ForkJoinPool.commonPool-worker-2: task2 res:null</span><br><span class="line">2019-06-23 19:50:53.552 ForkJoinPool.commonPool-worker-2: task2 exp:java.lang.RuntimeException: task2 RuntimeException</span><br><span class="line">2019-06-23 19:50:53.552 main: null</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="exceptionally"><a href="#exceptionally" class="headerlink" title="exceptionally"></a>exceptionally</h4><ul>
<li>异常处理逻辑，可以设置异常情况下的返回值</li>
<li>public CompletionStage<T> exceptionally(Function&lt;Throwable, ? extends T&gt; fn)<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public static void exceptionallyDemo() &#123;</span><br><span class="line">    Object result = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        sleep(20);</span><br><span class="line">        throw new RuntimeException(&quot;task2 RuntimeException&quot;);</span><br><span class="line">    &#125;).exceptionally(e-&gt;&#123;</span><br><span class="line">        System.out.println(&quot;exceptionally: &quot; +e);</span><br><span class="line">        return e.getMessage();</span><br><span class="line">    &#125;).join();</span><br><span class="line">    System.out.println(&quot;exceptionallyDemo: &quot; +result);</span><br><span class="line">&#125;</span><br><span class="line">--------- 输出 -----------</span><br><span class="line">exceptionally: java.util.concurrent.CompletionException: java.lang.RuntimeException: task2 RuntimeException</span><br><span class="line">exceptionallyDemo: java.lang.RuntimeException: task2 RuntimeException</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h3><ul>
<li><p>public boolean isDone()</p>
<ul>
<li>是否已经完成（包括正常完成，异常完成，取消完成）</li>
</ul>
</li>
<li><p>public T get() throws InterruptedException, ExecutionException</p>
<ul>
<li>阻塞方式获取结果</li>
</ul>
</li>
<li><p>public T get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException</p>
<ul>
<li>带超时方式的阻塞方式获取结果</li>
</ul>
</li>
<li><p>public T join() </p>
<ul>
<li>阻塞至任务完成。会抛出CompletionException(unchecked类型)</li>
</ul>
</li>
<li><p>public T getNow(T valueIfAbsent) </p>
<ul>
<li>立即获取结果，如果任务没有执行完成，则返回valueIfAbsent</li>
</ul>
</li>
<li><p>public boolean complete(T value)</p>
<ul>
<li>如果任务还没有执行完成，则用当前值去替换完成值，否则继续使用原始值。  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">private static void completeDemo() &#123;</span><br><span class="line">    println(&quot;complete start&quot;);</span><br><span class="line">    CompletableFuture&lt;String&gt; task = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        println(&quot;runAsync start&quot;);</span><br><span class="line">        sleep(2000);</span><br><span class="line">        println(&quot;runAsync end&quot;);</span><br><span class="line">        return &quot;task run finish&quot;;</span><br><span class="line">    &#125;);</span><br><span class="line">    boolean complete = task.complete(&quot;finish&quot;);</span><br><span class="line">    System.out.println(&quot;complete:&quot;+complete);</span><br><span class="line">    System.out.println(&quot;task:&quot;+task.join());</span><br><span class="line">    println(&quot;complete end&quot;);</span><br><span class="line">&#125;</span><br><span class="line">--------- 输出 -----------</span><br><span class="line">2019-06-23 20:55:19.491 main: complete start</span><br><span class="line">complete:true</span><br><span class="line">task:finish</span><br><span class="line">2019-06-23 20:55:19.547 main: complete end</span><br><span class="line">------------------------------------------------------------------------</span><br><span class="line">private static void completeDemo() &#123;</span><br><span class="line">    println(&quot;complete start&quot;);</span><br><span class="line">    CompletableFuture&lt;String&gt; task = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        println(&quot;runAsync start&quot;);</span><br><span class="line">        sleep(1);</span><br><span class="line">        println(&quot;runAsync end&quot;);</span><br><span class="line">        return &quot;task run finish&quot;;</span><br><span class="line">    &#125;);</span><br><span class="line">    sleep(10);</span><br><span class="line">    boolean complete = task.complete(&quot;finish&quot;);</span><br><span class="line">    System.out.println(&quot;complete:&quot;+complete);</span><br><span class="line">    System.out.println(&quot;task:&quot;+task.join());</span><br><span class="line">    println(&quot;complete end&quot;);</span><br><span class="line">&#125;</span><br><span class="line">--------- 输出 -----------</span><br><span class="line">2019-06-23 20:59:32.375 main: complete start</span><br><span class="line">2019-06-23 20:59:32.426 ForkJoinPool.commonPool-worker-1: runAsync start</span><br><span class="line">2019-06-23 20:59:32.428 ForkJoinPool.commonPool-worker-1: runAsync end</span><br><span class="line">complete:false</span><br><span class="line">task:task run finish</span><br><span class="line">2019-06-23 20:59:32.437 main: complete end</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>public boolean completeExceptionally(Throwable ex)</p>
<ul>
<li>如果任务还没有执行完成，则以异常的方式中断执行（调用join方法会抛出该异常），如果执行完成,则返回false，并正常执行  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">    private static void completeExceptionallyDemo() &#123;</span><br><span class="line">    println(&quot;completeExceptionally start&quot;);</span><br><span class="line">    CompletableFuture&lt;String&gt; task = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        println(&quot;supplyAsync start&quot;);</span><br><span class="line">        sleep(1);</span><br><span class="line">        println(&quot;supplyAsync end&quot;);</span><br><span class="line">        return &quot;task run finish&quot;;</span><br><span class="line">    &#125;);</span><br><span class="line">    sleep(10);</span><br><span class="line">    boolean complete = task.completeExceptionally(new NullPointerException(&quot;Test Null&quot;));</span><br><span class="line">    System.out.println(&quot;complete:&quot;+complete);</span><br><span class="line">    System.out.println(&quot;task:&quot;+task.join());</span><br><span class="line">    println(&quot;complete 1 end&quot;);</span><br><span class="line"></span><br><span class="line">    task = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        println(&quot;supplyAsync start&quot;);</span><br><span class="line">        sleep(1);</span><br><span class="line">        println(&quot;supplyAsync end&quot;);</span><br><span class="line">        return &quot;task run finish&quot;;</span><br><span class="line">    &#125;);</span><br><span class="line">    complete = task.completeExceptionally(new NullPointerException(&quot;Test Null&quot;));</span><br><span class="line">    System.out.println(&quot;complete:&quot;+complete);</span><br><span class="line">    System.out.println(&quot;task:&quot;+task.join());</span><br><span class="line">&#125;</span><br><span class="line">--------- 输出 -----------</span><br><span class="line">2019-06-23 21:11:48.276 main: completeExceptionally start</span><br><span class="line">2019-06-23 21:11:48.330 ForkJoinPool.commonPool-worker-1: supplyAsync start</span><br><span class="line">2019-06-23 21:11:48.331 ForkJoinPool.commonPool-worker-1: supplyAsync end</span><br><span class="line">complete:false</span><br><span class="line">task:task run finish</span><br><span class="line">2019-06-23 21:11:48.340 main: complete 1 end</span><br><span class="line">complete:true</span><br><span class="line">Exception in thread &quot;main&quot; java.util.concurrent.CompletionException: java.lang.NullPointerException: Test Null</span><br><span class="line">    at java.util.concurrent.CompletableFuture.reportJoin(CompletableFuture.java:375)</span><br><span class="line">    at java.util.concurrent.CompletableFuture.join(CompletableFuture.java:1934)</span><br><span class="line">    at com.example.demo.ThreadTest.completeExceptionallyDemo(ThreadTest.java:35)</span><br><span class="line">    at com.example.demo.ThreadTest.main(ThreadTest.java:9)</span><br><span class="line">Caused by: java.lang.NullPointerException: Test Null</span><br><span class="line">    at com.example.demo.ThreadTest.completeExceptionallyDemo(ThreadTest.java:33)</span><br><span class="line">    ... 1 more</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>public CompletableFuture<T> toCompletableFuture()</p>
<ul>
<li>返回CompletableFuture对象，实际代码中返回this</li>
</ul>
</li>
<li><p>public boolean cancel(boolean mayInterruptIfRunning)</p>
<ul>
<li>取消任务，mayInterruptIfRunning在当前实现没有任何作用。。（醉了）</li>
<li>任务取消后如果执行join方法会抛出CancellationException异常。  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">private static void cancelDemo() &#123;</span><br><span class="line">    CompletableFuture&lt;Void&gt; future = CompletableFuture.runAsync(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            println(&quot;Start&quot;);</span><br><span class="line">            sleep(1000);</span><br><span class="line">            println(&quot;End&quot;);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    sleep(10);</span><br><span class="line">    boolean cancel = future.cancel(true);</span><br><span class="line">    println(cancel);</span><br><span class="line">    System.out.println(&quot;----------------------------------&quot;);</span><br><span class="line">    future = CompletableFuture.runAsync(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            println(&quot;Start&quot;);</span><br><span class="line">            sleep(10);</span><br><span class="line">            println(&quot;End&quot;);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    sleep(100);</span><br><span class="line">    cancel = future.cancel(true);</span><br><span class="line">    println(cancel);</span><br><span class="line">&#125;</span><br><span class="line">--------- 输出 -----------</span><br><span class="line">2019-06-23 21:56:33.060 ForkJoinPool.commonPool-worker-1: Start</span><br><span class="line">2019-06-23 21:56:33.072 main: true</span><br><span class="line">----------------------------------</span><br><span class="line">2019-06-23 21:56:33.075 ForkJoinPool.commonPool-worker-2: Start</span><br><span class="line">2019-06-23 21:56:33.086 ForkJoinPool.commonPool-worker-2: End</span><br><span class="line">2019-06-23 21:56:33.176 main: false</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>public boolean isCancelled()</p>
<ul>
<li>返回当前任务是否已经被取消</li>
</ul>
</li>
<li><p>public boolean isCompletedExceptionally()</p>
<ul>
<li>返回当前任务是否异常方式中断</li>
</ul>
</li>
<li><p>public void obtrudeValue(T value)</p>
<ul>
<li>将future的结果强制更改为value，无论是否发生异常</li>
</ul>
</li>
<li><p>public void obtrudeException(Throwable ex)</p>
<ul>
<li>将future的结果强制更改为异常，只要调用get或者join均会抛出该异常,同时会修改isCompletedExceptionally的结果</li>
</ul>
</li>
<li><p>public int getNumberOfDependents()</p>
<ul>
<li>返回有多少个后续stage依赖当前stage  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">private static void getNumberOfDependentsDemo() &#123;</span><br><span class="line">    CompletableFuture&lt;String&gt; t1 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        sleep(1000);</span><br><span class="line">        return &quot;1&quot;;</span><br><span class="line">    &#125;);</span><br><span class="line">    CompletableFuture&lt;String&gt; t2 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        sleep(1000);</span><br><span class="line">        return &quot;2&quot;;</span><br><span class="line">    &#125;);</span><br><span class="line">    sleep(10);</span><br><span class="line">    println(t1.getNumberOfDependents());</span><br><span class="line">    println(t2.getNumberOfDependents());</span><br><span class="line">    CompletableFuture&lt;Void&gt; all = CompletableFuture.allOf(t1, t2);</span><br><span class="line">    println(all.isDone());</span><br><span class="line">    println(t1.getNumberOfDependents());</span><br><span class="line">    println(t2.getNumberOfDependents());</span><br><span class="line">    all.join();</span><br><span class="line">    println(t1.getNumberOfDependents());</span><br><span class="line">    println(t2.getNumberOfDependents());</span><br><span class="line">&#125;</span><br><span class="line">--------- 输出 -----------</span><br><span class="line">2019-06-23 22:26:45.132 main: 0</span><br><span class="line">2019-06-23 22:26:45.133 main: 0</span><br><span class="line">2019-06-23 22:26:45.133 main: false</span><br><span class="line">2019-06-23 22:26:45.133 main: 1</span><br><span class="line">2019-06-23 22:26:45.133 main: 1</span><br><span class="line">2019-06-23 22:26:46.122 main: 0</span><br><span class="line">2019-06-23 22:26:46.122 main: 0</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/6bac52527ca4">https://www.jianshu.com/p/6bac52527ca4</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/558b090ae4bb">https://www.jianshu.com/p/558b090ae4bb</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jb51.net/article/51163.htm">https://www.jb51.net/article/51163.htm</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/dennyzhangdd/p/7010972.html">https://www.cnblogs.com/dennyzhangdd/p/7010972.html</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html?is-external=true">https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html?is-external=true</a></li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://eviltuzki.top/2019/06/13/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Eviltuzki">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eviltuzki">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/06/13/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E8%AF%A6%E8%A7%A3/" class="post-title-link" itemprop="url">I/O 多路复用之select、poll、epoll详解</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-06-13 00:00:00" itemprop="dateCreated datePublished" datetime="2019-06-13T00:00:00+08:00">2019-06-13</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/IO/" itemprop="url" rel="index"><span itemprop="name">IO</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <hr>
<p>select，poll，epoll都是IO多路复用的机制。I&#x2F;O多路复用就是通过一种机制，一个进程可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。但select，poll，epoll本质上都是同步I&#x2F;O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I&#x2F;O则无需自己负责进行读写，异步I&#x2F;O的实现会负责把数据从内核拷贝到用户空间。</p>
<hr>
<h2 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h2><h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><ul>
<li>基本原理：<ul>
<li>select 函数监视的文件描述符分3类，分别是writefds、readfds、和exceptfds。</li>
<li>调用后select函数会阻塞，直到有描述符就绪（有数据 可读、可写、或者有except），或者超时（timeout指定等待时间，如果立即返回设为null即可），函数返回。</li>
<li>当select函数返回后，可以通过遍历fdset，来找到就绪的描述符。</li>
</ul>
</li>
<li>select目前几乎在所有的平台上支持，其良好跨平台支持也是它的一个优点。</li>
<li>select最大的缺陷就是单个进程所打开的FD是有一定限制的，它由FD_SETSIZE设置，默认值是1024。<ul>
<li>一般来说这个数目和系统内存关系很大，具体数目可以cat &#x2F;proc&#x2F;sys&#x2F;fs&#x2F;file-max察看。32位机默认是1024个。64位机默认是2048.</li>
</ul>
</li>
<li>对socket进行扫描时是线性扫描，即采用轮询的方法，效率较低。<ul>
<li>当套接字比较多的时候，每次select()都要通过遍历FD_SETSIZE个Socket来完成调度，不管哪个Socket是活跃的，都遍历一遍。这会浪费很多CPU时间。如果能给套接字注册某个回调函数，当他们活跃时，自动完成相关操作，那就避免了轮询，这正是epoll与kqueue做的。</li>
</ul>
</li>
<li>需要维护一个用来存放大量fd的数据结构，这样会使得用户空间和内核空间在传递该结构时复制开销大。</li>
<li>简述：1024</li>
</ul>
<h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h3><ul>
<li>基本原理：<ul>
<li>poll本质上和select没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态。</li>
<li>如果设备就绪则在设备等待队列中加入一项并继续遍历，如果遍历完所有fd后没有发现就绪设备，则挂起当前进程，直到设备就绪或者主动超时，被唤醒后它又要再次遍历fd。</li>
<li>这个过程经历了多次无谓的遍历。</li>
</ul>
</li>
<li>pollfd结构包含了要监视的event和发生的event，不再使用select“参数-值”传递的方式。</li>
<li>同时，pollfd并没有最大数量限制（但是数量过大后性能也是会下降）。</li>
<li>和select函数一样，poll返回后，需要轮询pollfd来获取就绪的描述符。</li>
<li>poll还有一个特点是“水平触发”，如果报告了fd后，没有被处理，那么下次poll时会再次报告该fd。</li>
<li>从上面看，select和poll都需要在返回后，通过遍历文件描述符来获取已经就绪的socket。</li>
<li>事实上，同时连接的大量客户端在一时刻可能只有很少的处于就绪状态，因此随着监视的描述符数量的增长，其效率也会线性下降。</li>
<li>简述：鸡肋</li>
</ul>
<h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><ul>
<li>epoll是在2.6内核中提出的，是之前的select和poll的增强版本。</li>
<li>相对于select和poll来说，epoll更加灵活，没有描述符限制。</li>
<li>epoll使用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的copy只需一次。</li>
<li>没有最大并发连接的限制，能打开的FD的上限远大于1024（1G的内存上能监听约10万个端口）。</li>
<li>效率提升，不是轮询的方式，不会随着FD数目的增加效率下降。<ul>
<li>只有活跃可用的FD才会调用callback函数；即Epoll最大的优点就在于它只管你“活跃”的连接，而跟连接总数无关，因此在实际的网络环境中，Epoll的效率就会远远高于select和poll。</li>
</ul>
</li>
<li>内存拷贝，利用mmap()文件映射内存加速与内核空间的消息传递；即epoll使用mmap减少复制开销。</li>
<li>简述：杀手锏</li>
</ul>
<h4 id="epoll工作模式"><a href="#epoll工作模式" class="headerlink" title="epoll工作模式"></a>epoll工作模式</h4><ul>
<li>epoll对文件描述符的操作有两种模式：LT（level trigger）和ET（edge trigger）。LT模式是默认模式，LT模式与ET模式的区别如下：<ul>
<li>LT模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序可以不立即处理该事件。下次调用epoll_wait时，会再次响应应用程序并通知此事件。</li>
<li>ET模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序必须立即处理该事件。如果不处理，下次调用epoll_wait时，不会再次响应应用程序并通知此事件。</li>
</ul>
</li>
</ul>
<h5 id="LT模式"><a href="#LT模式" class="headerlink" title="LT模式"></a>LT模式</h5><ul>
<li>LT(level triggered)是缺省的工作方式，并且同时支持block和no-block socket.在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的fd进行IO操作。如果你不作任何操作，内核还是会继续通知你的。</li>
</ul>
<h5 id="ET模式"><a href="#ET模式" class="headerlink" title="ET模式"></a>ET模式</h5><ul>
<li>ET(edge-triggered)是高速工作方式，只支持no-block socket。在这种模式下，当描述符从未就绪变为就绪时，内核通过epoll告诉你。然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知，直到你做了某些操作导致那个文件描述符不再为就绪状态了(比如，你在发送，接收或者接收请求，或者发送接收的数据少于一定量时导致了一个EWOULDBLOCK 错误）。但是请注意，如果一直不对这个fd作IO操作(从而导致它再次变成未就绪)，内核不会发送更多的通知(only once)</li>
<li>ET模式在很大程度上减少了epoll事件被重复触发的次数，因此效率要比LT模式高。epoll工作在ET模式的时候，必须使用非阻塞套接口，以避免由于一个文件句柄的阻塞读&#x2F;阻塞写操作把处理多个文件描述符的任务饿死。</li>
</ul>
<h4 id="epoll总结"><a href="#epoll总结" class="headerlink" title="epoll总结"></a>epoll总结</h4><ul>
<li>在 select&#x2F;poll中，进程只有在调用一定的方法后，内核才对所有监视的文件描述符进行扫描，而<em>epoll事先通过epoll_ctl()来注册一 个文件描述符，一旦基于某个文件描述符就绪时，内核会采用类似callback的回调机制，迅速激活这个文件描述符，当进程调用epoll_wait() 时便得到通知。</em>(此处去掉了遍历文件描述符，而是通过监听回调的的机制。这正是epoll的魅力所在。)</li>
<li>epoll的优点主要是一下几个方面：<ul>
<li>监视的描述符数量不受限制，它所支持的FD上限是最大可以打开文件的数目，这个数字一般远大于2048,举个例子,在1GB内存的机器上大约是10万左 右，具体数目可以cat &#x2F;proc&#x2F;sys&#x2F;fs&#x2F;file-max察看,一般来说这个数目和系统内存关系很大。select的最大缺点就是进程打开的fd是有数量限制的。这对 于连接数量比较大的服务器来说根本不能满足。虽然也可以选择多进程的解决方案( Apache就是这样实现的)，不过虽然linux上面创建进程的代价比较小，但仍旧是不可忽视的，加上进程间数据同步远比不上线程间同步的高效，所以也不是一种完美的方案。</li>
<li>IO的效率不会随着监视fd的数量的增长而下降。epoll不同于select和poll轮询的方式，而是通过每个fd定义的回调函数来实现的。只有就绪的fd才会执行回调函数。</li>
<li>如果没有大量的idle -connection或者dead-connection，epoll的效率并不会比select&#x2F;poll高很多，但是当遇到大量的idle- connection，就会发现epoll的效率大大高于select&#x2F;poll。</li>
</ul>
</li>
</ul>
<h2 id="select、poll、epoll区别"><a href="#select、poll、epoll区别" class="headerlink" title="select、poll、epoll区别"></a>select、poll、epoll区别</h2><p>1、支持一个进程所能打开的最大连接数<br><img src="/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E8%AF%A6%E8%A7%A3/1.png" alt="最大连接数"><br>2、FD剧增后带来的IO效率问题<br><img src="/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E8%AF%A6%E8%A7%A3/2.png" alt="IO效率问题"><br>3、消息传递方式<br><img src="/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E8%AF%A6%E8%A7%A3/3.png" alt="消息传递方式"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://eviltuzki.top/2019/06/12/%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4%E4%B8%8E%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Eviltuzki">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eviltuzki">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/06/12/%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4%E4%B8%8E%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4/" class="post-title-link" itemprop="url">用户空间与内核空间</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-06-12 00:00:00" itemprop="dateCreated datePublished" datetime="2019-06-12T00:00:00+08:00">2019-06-12</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <hr>
<ul>
<li><p>我们知道现在操作系统都是采用虚拟存储器，那么对32位操作系统而言，它的寻址空间（虚拟存储空间）为4G（2的32次方）。</p>
</li>
<li><p>操心系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。为了保证用户进程不能直接操作内核，保证内核的安全，操心系统将虚拟空间划分为两部分，一部分为内核空间，一部分为用户空间。</p>
</li>
<li><p>针对linux操作系统而言，将最高的1G字节（从虚拟地址0xC0000000到0xFFFFFFFF），供内核使用，称为内核空间，而将较低的3G字节（从虚拟地址0x00000000到0xBFFFFFFF），供各个进程使用，称为用户空间。</p>
</li>
<li><p>每个进程可以通过系统调用进入内核，因此，Linux内核由系统内的所有进程共享。于是，从具体进程的角度来看，每个进程可以拥有4G字节的虚拟空间。</p>
</li>
<li><p>空间分配如下图所示：<br><img src="/%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4%E4%B8%8E%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4/1.png" alt="空间分配图"></p>
</li>
<li><p>有了用户空间和内核空间，整个linux内部结构可以分为三部分，从最底层到最上层依次是：硬件–&gt;内核空间–&gt;用户空间。如下图所示：<br><img src="/%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4%E4%B8%8E%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4/2.png" alt="linux内部结构图"></p>
</li>
<li><p>需要注意的细节问题：</p>
<ul>
<li>内核空间中存放的是内核代码和数据，而进程的用户空间中存放的是用户程序的代码和数据。不管是内核空间还是用户空间，它们都处于虚拟空间中。 </li>
<li>Linux使用两级保护机制：0级供内核使用，3级供用户程序使用。</li>
</ul>
</li>
<li><p>内核态与用户态：</p>
<ul>
<li>当一个任务（进程）执行系统调用而陷入内核代码中执行时，称进程处于内核运行态（内核态）。此时处理器处于特权级最高的（0级）内核代码中执行。当进程处于内核态时，执行的内核代码会使用当前进程的内核栈。每个进程都有自己的内核栈。</li>
<li>当进程在执行用户自己的代码时，则称其处于用户运行态（用户态）。此时处理器在特权级最低的（3级）用户代码中运行。当正在执行用户程序而突然被中断程序中断时，此时用户程序也可以象征性地称为处于进程的内核态。因为中断处理程序将使用当前进程的内核栈。</li>
</ul>
</li>
<li><p>参考资料：</p>
<ul>
<li>用户空间与内核空间，进程上下文与中断上下文[总结][<a target="_blank" rel="noopener" href="https://www.cnblogs.com/Anker/p/3269106.html]">https://www.cnblogs.com/Anker/p/3269106.html]</a></li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://eviltuzki.top/2019/06/02/Java%20NIO%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Eviltuzki">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eviltuzki">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/06/02/Java%20NIO%E5%AD%A6%E4%B9%A0/" class="post-title-link" itemprop="url">Java NIO学习笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-06-02 00:00:00" itemprop="dateCreated datePublished" datetime="2019-06-02T00:00:00+08:00">2019-06-02</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ul>
<li>内容基本来源:<ul>
<li><a target="_blank" rel="noopener" href="http://www.iocoder.cn/">http://www.iocoder.cn/</a></li>
<li><a target="_blank" rel="noopener" href="http://ifeve.com/">http://ifeve.com</a></li>
</ul>
</li>
</ul>
<h2 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h2><h3 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h3><ul>
<li>Nio Channel类似于Java Stream，但又有几点不同<ul>
<li>Channel是双向的，Stream是单向的</li>
<li>Channel可以非阻塞的进行读写操作，而Stream需要等待io操作完成，也就是阻塞的。</li>
<li>Channel的读操作或者写操作都是依赖Buffer的，Stream没有依赖</li>
</ul>
</li>
</ul>
<h4 id="ServerSocketChannel"><a href="#ServerSocketChannel" class="headerlink" title="ServerSocketChannel"></a>ServerSocketChannel</h4><ul>
<li>Java NIO中的 ServerSocketChannel 是一个可以监听新进来的TCP连接的通道, 就像标准IO中的ServerSocket一样。</li>
<li>ServerSocketChannel类在 java.nio.channels包中。</li>
</ul>
<h4 id="SocketChannel"><a href="#SocketChannel" class="headerlink" title="SocketChannel"></a>SocketChannel</h4><ul>
<li>Java NIO中的SocketChannel是一个连接到TCP网络套接字的通道。</li>
<li>可以通过以下2种方式创建SocketChannel：<ul>
<li>打开一个SocketChannel并连接到互联网上的某台服务器。</li>
<li>一个新连接到达ServerSocketChannel时，会创建一个SocketChannel。</li>
</ul>
</li>
<li>非阻塞模式与选择器搭配会工作的更好，通过将一或多个SocketChannel注册到Selector，可以询问选择器哪个通道已经准备好了读取，写入等。</li>
</ul>
<h4 id="DatagramChannel"><a href="#DatagramChannel" class="headerlink" title="DatagramChannel"></a>DatagramChannel</h4><ul>
<li>Java NIO中的DatagramChannel是一个能收发UDP包的通道。</li>
<li>因为UDP是无连接的网络协议，所以不能像其它通道那样读取和写入。</li>
<li>它发送和接收的是数据包。</li>
</ul>
<h4 id="FileChannel"><a href="#FileChannel" class="headerlink" title="FileChannel"></a>FileChannel</h4><ul>
<li>Java NIO中的FileChannel是一个连接到文件的通道。可以通过文件通道读写文件。</li>
<li>FileChannel无法设置为非阻塞模式，它总是运行在阻塞模式下。</li>
</ul>
<h3 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h3><ul>
<li>一个 Buffer，本质上是内存中的一块，我们可以将数据写入这块内存，之后从这块内存获取数据。通过将这块内存封装成 NIO Buffer 对象，并提供了一组常用的方法，方便我们对该块内存的读写。</li>
<li>基本属性<ul>
<li>capacity<ul>
<li>属性，容量，Buffer 能容纳的数据元素的最大值。这一容量在 Buffer 创建时被赋值，并且永远不能被修改。</li>
</ul>
</li>
<li>limit<ul>
<li>属性，上限。</li>
<li>写模式下，代表最大能写入的数据上限位置，这个时候 limit 等于 capacity 。</li>
<li>读模式下，在 Buffer 完成所有数据写入后，通过调用 #flip() 方法，切换到读模式。此时，limit 等于 Buffer 中实际的数据大小。因为 Buffer 不一定被写满，所以不能使用 capacity 作为实际的数据大小。</li>
</ul>
</li>
<li>position<ul>
<li>position 属性，位置，初始值为 0 。</li>
<li>写模式下，每往 Buffer 中写入一个值，position 就自动加 1 ，代表下一次的写入位置。</li>
<li>读模式下，每从 Buffer 中读取一个值，position 就自动加 1 ，代表下一次的读取位置。( 和写模式类似 )</li>
</ul>
</li>
<li>mark <ul>
<li>属性，标记，通过 #mark() 方法，记录当前 position ；通过 reset() 方法，恢复 position 为标记。</li>
<li>写模式下，标记上一次写位置。</li>
<li>读模式下，标记上一次读位置。</li>
</ul>
</li>
<li>关系<ul>
<li>mark &lt;&#x3D; position &lt;&#x3D; limit &lt;&#x3D; capacity</li>
</ul>
</li>
</ul>
</li>
<li>创建Buffer<ul>
<li>每个 Buffer 实现类，都提供了 #allocate(int capacity) 静态方法，帮助我们快速实例化一个 Buffer 对象。<ul>
<li>ByteBuffer 实际是个抽象类，返回的是它的基于堆内( Non-Direct )内存的实现类 HeapByteBuffer 的对象。</li>
</ul>
</li>
<li>每个 Buffer 实现类，都提供了 #wrap(array) 静态方法，帮助我们将其对应的数组包装成一个 Buffer 对象。<ul>
<li>和 #allocate(int capacity) 静态方法一样，返回的也是 HeapByteBuffer 的对象。</li>
</ul>
</li>
<li>每个 Buffer 实现类，都提供了 #allocateDirect(int capacity) 静态方法，帮助我们快速实例化一个 Buffer 对象。<ul>
<li>和 #allocate(int capacity) 静态方法不一样，返回的是它的基于堆外( Direct )内存的实现类 DirectByteBuffer 的对象。</li>
</ul>
</li>
</ul>
</li>
<li>向 Buffer 写入数据<ul>
<li>每个 Buffer 实现类，都提供了 #put(…) 方法，向 Buffer 写入数据。</li>
<li>对于 Buffer 来说，有一个非常重要的操作就是，我们要讲来自 Channel 的数据写入到 Buffer 中。</li>
<li>在系统层面上，这个操作我们称为读操作，因为数据是从外部( 文件或者网络等 )读取到内存中。</li>
<li>通常在说 NIO 的读操作的时候，我们说的是从 Channel 中读数据到 Buffer 中，对应的是对 Buffer 的写入操作</li>
</ul>
</li>
<li>从 Buffer 读取数据<ul>
<li>每个 Buffer 实现类，都提供了 #get(…) 方法，从 Buffer 读取数据。</li>
<li>对于 Buffer 来说，还有一个非常重要的操作就是，我们要讲来向 Channel 的写入 Buffer 中的数据。</li>
<li>在系统层面上，这个操作我们称为写操作，因为数据是从内存中写入到外部( 文件或者网络等 )。</li>
</ul>
</li>
<li>rewind()  flip()   clear()<ul>
<li>flip  <ul>
<li>如果要读取 Buffer 中的数据，需要切换模式，从写模式切换到读模式。</li>
</ul>
</li>
<li>rewind<ul>
<li>可以重置 position 的值为 0 。因此，我们可以重新读取和写入 Buffer 了。</li>
<li>该方法主要针对于读模式，所以可以翻译为“倒带”。</li>
</ul>
</li>
<li>clear<ul>
<li>可以“重置” Buffer 的数据。因此，我们可以重新读取和写入 Buffer 了。</li>
<li>该方法主要针对于写模式。</li>
<li>Buffer 的数据实际并未清理掉</li>
</ul>
</li>
</ul>
</li>
<li>mark() 搭配 reset()<ul>
<li>mark<ul>
<li>保存当前的 position 到 mark 中。</li>
</ul>
</li>
<li>reset<ul>
<li>恢复当前的 postion 为 mark 。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="关于-Direct-Buffer-和-Non-Direct-Buffer-的区别"><a href="#关于-Direct-Buffer-和-Non-Direct-Buffer-的区别" class="headerlink" title="关于 Direct Buffer 和 Non-Direct Buffer 的区别"></a>关于 Direct Buffer 和 Non-Direct Buffer 的区别</h4><ul>
<li>Direct Buffer:<ul>
<li>所分配的内存不在 JVM 堆上, 不受 GC 的管理.(但是 Direct Buffer 的 Java 对象是由 GC 管理的, 因此当发生 GC, 对象被回收时, Direct Buffer 也会被释放)</li>
<li>因为 Direct Buffer 不在 JVM 堆上分配, 因此 Direct Buffer 对应用程序的内存占用的影响就不那么明显(实际上还是占用了这么多内存, 但是 JVM 不好统计到非 JVM 管理的内存.)</li>
<li>申请和释放 Direct Buffer 的开销比较大. 因此正确的使用 Direct Buffer 的方式是在初始化时申请一个 Buffer, 然后不断复用此 buffer, 在程序结束后才释放此 buffer.</li>
<li>使用 Direct Buffer 时, 当进行一些底层的系统 IO 操作时, 效率会比较高, 因为此时 JVM 不需要拷贝 buffer 中的内存到中间临时缓冲区中.</li>
</ul>
</li>
<li>Non-Direct Buffer:<ul>
<li>直接在 JVM 堆上进行内存的分配, 本质上是 byte[] 数组的封装.</li>
<li>因为 Non-Direct Buffer 在 JVM 堆中, 因此当进行操作系统底层 IO 操作中时, 会将此 buffer 的内存复制到中间临时缓冲区中. 因此 Non-Direct Buffer 的效率就较低.</li>
</ul>
</li>
</ul>
<h3 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h3><ul>
<li>Selector ， 一般称为选择器。它是 Java NIO 核心组件中的一个，用于轮询一个或多个 NIO Channel 的状态是否处于可读、可写。如此，一个线程就可以管理多个 Channel ，也就说可以管理多个网络连接。也因此，Selector 也被称为多路复用器。</li>
<li>那么 Selector 是如何轮询的呢？<ul>
<li>首先，需要将 Channel 注册到 Selector 中，这样 Selector 才知道哪些 Channel 是它需要管理的。</li>
<li>之后，Selector 会不断地轮询注册在其上的 Channel 。如果某个 Channel 上面发生了读或者写事件，这个 Channel 就处于就绪状态，会被 Selector 轮询出来，然后通过 SelectionKey 可以获取就绪 Channel 的集合，进行后续的 I&#x2F;O 操作。</li>
</ul>
</li>
<li>优缺点<ul>
<li>优点<ul>
<li>使用一个线程能够处理多个 Channel 的优点是，只需要更少的线程来处理 Channel 。</li>
<li>事实上，可以使用一个线程处理所有的 Channel 。</li>
<li>对于操作系统来说，线程之间上下文切换的开销很大，而且每个线程都要占用系统的一些资源( 例如 CPU、内存 )。因此，使用的线程越少越好。</li>
</ul>
</li>
<li>缺点<ul>
<li>因为在一个线程中使用了多个 Channel ，因此会造成每个 Channel 处理效率的降低。</li>
</ul>
</li>
</ul>
</li>
<li>创建 Selector<ul>
<li>通过 #open() 方法，我们可以创建一个 Selector 对象。代码如下：</li>
</ul>
</li>
<li>注册 Chanel 到 Selector 中<ul>
<li>为了让 Selector 能够管理 Channel ，我们需要将 Channel 注册到 Selector 中。</li>
<li>如果一个 Channel 要注册到 Selector 中，那么该 Channel 必须是非阻塞。</li>
<li>FileChannel 是不能够注册到 Channel 中的，因为它是阻塞的。</li>
<li>监听四种不同类型的事件：<ul>
<li>Connect ：连接完成事件( TCP 连接 )，仅适用于客户端，对应 SelectionKey.OP_CONNECT 。</li>
<li>Accept ：接受新连接事件，仅适用于服务端，对应 SelectionKey.OP_ACCEPT 。</li>
<li>Read ：读事件，适用于两端，对应 SelectionKey.OP_READ ，表示 Buffer 可读。</li>
<li>Write ：写时间，适用于两端，对应 SelectionKey.OP_WRITE ，表示 Buffer 可写。</li>
</ul>
</li>
<li>Channel 触发了一个事件，意思是该事件已经就绪：<ul>
<li>一个 Client Channel Channel 成功连接到另一个服务器，称为“连接就绪”。</li>
<li>一个 Server Socket Channel 准备好接收新进入的连接，称为“接收就绪”。</li>
<li>一个有数据可读的 Channel ，可以说是“读就绪”。</li>
<li>一个等待写数据的 Channel ，可以说是“写就绪”。</li>
</ul>
</li>
</ul>
</li>
<li>SelectionKey 类<ul>
<li>调用 Channel 的 #register(…) 方法，向 Selector 注册一个 Channel 后，会返回一个 SelectionKey 对象。</li>
<li>SelectionKey 在 java.nio.channels 包下，被定义成一个抽象类，表示一个 Channel 和一个 Selector 的注册关系。</li>
<li>注册关系，包含如下内容：<ul>
<li>interest set: 感兴趣的事件集合。</li>
<li>ready set ：就绪的事件集合。</li>
<li>Channel</li>
<li>Selector</li>
<li>attachment ：可选的附加对象。可以向 SelectionKey 添加附加对象。</li>
</ul>
</li>
</ul>
</li>
<li>通过 Selector 选择 Channel<ul>
<li>在 Selector 中，提供三种类型的选择( select )方法，返回当前有感兴趣事件准备就绪的 Channel 数量。<ul>
<li>select() 阻塞到至少有一个 Channel 在你注册的事件上就绪了。</li>
<li>select(long timeout) 在 <code>#select()</code> 方法的基础上，增加超时机制。</li>
<li>selectNow() 和 <code>#select()</code> 方法不同，立即返回数量，而不阻塞。</li>
</ul>
</li>
<li>select 方法返回的 int 值，表示有多少 Channel 已经就绪。也就是自上次调用 select 方法后有多少 Channel 变成就绪状态。</li>
</ul>
</li>
<li>获取可操作的 Channel<ul>
<li>一旦调用了 select 方法，并且返回值表明有一个或更多个 Channel 就绪了，然后可以通过调用Selector 的 #selectedKeys() 方法，访问“已选择键集( selected key set )”中的就绪 Channel 。</li>
<li>注意，当有新增就绪的 Channel ，需要先调用 select 方法，才会添加到“已选择键集( selected key set )”中。否则，我们直接调用 #selectedKeys() 方法，是无法获得它们对应的 SelectionKey 们。</li>
</ul>
</li>
<li>唤醒 Selector 选择<ul>
<li>某个线程调用 #select() 方法后，发生阻塞了，即使没有通道已经就绪，也有办法让其从 #select() 方法返回。</li>
<li>只要让其它线程在第一个线程调用 select() 方法的那个 Selector 对象上，调用该 Selector 的 #wakeup() 方法，进行唤醒该 Selector 即可。</li>
<li>注意，如果有其它线程调用了 #wakeup() 方法，但当前没有线程阻塞在 #select() 方法上，下个调用 #select() 方法的线程会立即被唤醒。</li>
</ul>
</li>
<li>关闭 Selector<ul>
<li>当我们不再使用 Selector 时，可以调用 Selector 的 #close() 方法，将它进行关闭。<ul>
<li>Selector 相关的所有 SelectionKey 都会失效。</li>
<li>Selector 相关的所有 Channel 并不会关闭。</li>
</ul>
</li>
<li>此时若有线程阻塞在 #select() 方法上，也会被唤醒返回。</li>
</ul>
</li>
</ul>
<h2 id="NIO与BIO相比"><a href="#NIO与BIO相比" class="headerlink" title="NIO与BIO相比"></a>NIO与BIO相比</h2><h3 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h3><ul>
<li>基于缓冲区<ul>
<li>基于Buffer读取，将数据从Channel中读取到Buffer中，或者从buffer中将数据写回到channel中。因为数据已经读取到缓冲区当中，所以操作不需要顺序执行，增加其灵活性。</li>
</ul>
</li>
<li>非阻塞IO<ul>
<li>一个线程从channel中执行io操作的时候，无论是读取还是写入，都无需等待完成，都会直接返回，不会阻塞当前正在执行的线程。</li>
</ul>
</li>
<li>有选择器<ul>
<li>一个线程可以通过一个Selector管理多个Channel，选择器是实现非阻塞io的核心。</li>
<li>Selector内部自动为我们实现了轮训select操作，判断channel是否有已经就绪的io事件（连接，读，写等）</li>
</ul>
</li>
</ul>
<h3 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h3><ul>
<li>基于流(Stream)<ul>
<li>以流式方式进行处理，顺序的从一个stream中读取一个或者多个字节，直到读取完成。由于没有缓存区，不能随意更改读取指针的位置。</li>
</ul>
</li>
<li>阻塞IO<ul>
<li>一个线程操作io的时候，该线程会被阻塞，直到数据被读取或者写入完成。</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://eviltuzki.top/2019/05/08/MySQL%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93(4)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Eviltuzki">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eviltuzki">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/05/08/MySQL%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93(4)/" class="post-title-link" itemprop="url">MySQL学习总结(4)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-05-08 00:00:00" itemprop="dateCreated datePublished" datetime="2019-05-08T00:00:00+08:00">2019-05-08</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MySQL/" itemprop="url" rel="index"><span itemprop="name">MySQL</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p>根据加锁的范围，MySQL里面的锁大致可以分为全局锁，表级锁和行级锁。</p>
<h1 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h1><ul>
<li>MySql提供了一个加全局锁的方法，Flush tables with read lock(FTWRL)</li>
<li>适用场景：全库逻辑备份</li>
<li>阻塞: 数据更新语句，数据定义语句，更新类事务提交语句</li>
</ul>
<h1 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h1><ul>
<li>MySql中表级锁有两种：表锁 和 元数据锁</li>
</ul>
<h2 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h2><ul>
<li>表锁语法是: lock tables … read&#x2F;write</li>
<li>对于InnoDB这种支持行锁的引擎，一般不使用lock tables方式控制并发</li>
</ul>
<h2 id="元数据锁（matedata-lock，MDL）"><a href="#元数据锁（matedata-lock，MDL）" class="headerlink" title="元数据锁（matedata lock，MDL）"></a>元数据锁（matedata lock，MDL）</h2><ul>
<li>MDL不需要显示使用，在访问一个表的时候会被自动加上。</li>
<li>作用：保证读写的正确性。</li>
<li>增删改查操作自动加MDL读锁，修改表结构的时候加MDL写锁</li>
</ul>
<h1 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h1><ul>
<li>问题: 即使把所有的记录都加上锁，也还是阻止不了新插入的记录。</li>
</ul>
<h2 id="如何解决幻读问题"><a href="#如何解决幻读问题" class="headerlink" title="如何解决幻读问题"></a>如何解决幻读问题</h2><ul>
<li>产生幻读的原因是：行锁只能锁住行，新插入记录这个动作，要更新的是记录之间的间隙。</li>
<li>解决办法： InnoDB引入了新的锁，间隙锁(Gap Lock)</li>
<li>与间隙锁冲突的操作:往这个间隙中插入一条记录</li>
<li>间隙锁和行锁合称：next-key lock</li>
</ul>
<h1 id="加锁总结"><a href="#加锁总结" class="headerlink" title="加锁总结"></a>加锁总结</h1><ul>
<li><p>原则1：加锁的基本单位是next-key lock，是前开后闭区间。</p>
</li>
<li><p>原则2：查找过程中访问到的对象才会加锁。</p>
</li>
<li><p>优化1：索引上的等值查询，给唯一索引加锁的时候，next-key lock 退化为行锁。</p>
</li>
<li><p>优化2：索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，next-key lock退化为间隙锁。</p>
</li>
<li><p>Bug：唯一索引上的范围查询会访问到不满足条件的第一个值为止。</p>
</li>
<li><p>锁是加在索引上的</p>
</li>
<li><p>用lock in share mode来给行加读锁避免数据被更新的话，必须要绕过覆盖索引优化，查询字段中加入索引中不存在的字段。</p>
</li>
<li><p>分析加锁规则的时候可以用next-key lock来进行分析，但是具体执行的时候，是要分成间隙锁和行锁两阶段来执行的。</p>
</li>
</ul>
<hr>
<ul>
<li>源：&lt;极客时间&gt; MySQL实战45讲教程</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://eviltuzki.top/2019/05/07/MySQL%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93(3)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Eviltuzki">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eviltuzki">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/05/07/MySQL%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93(3)/" class="post-title-link" itemprop="url">MySQL学习总结(3)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-05-07 00:00:00" itemprop="dateCreated datePublished" datetime="2019-05-07T00:00:00+08:00">2019-05-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MySQL/" itemprop="url" rel="index"><span itemprop="name">MySQL</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><h1 id="索引常见模型"><a href="#索引常见模型" class="headerlink" title="索引常见模型"></a>索引常见模型</h1><ul>
<li>哈希表</li>
<li>适用于只有等值查询的场景</li>
<li>有序数组</li>
<li>适用于等值查询，范围查询</li>
<li>更新成本高，适用于静态存储引擎</li>
<li>搜索树</li>
<li>查询复杂度O(log(N))</li>
<li>更新操作复杂度O(log(N))</li>
<li>为了适配磁盘，往往使用N叉树</li>
</ul>
<h1 id="InnoDB索引模型"><a href="#InnoDB索引模型" class="headerlink" title="InnoDB索引模型"></a>InnoDB索引模型</h1><ul>
<li><p>表都是根据主键顺序以索引形式存放。</p>
</li>
<li><p>使用了B+树索引模型，数据存储在B+树中。</p>
</li>
<li><p>根据叶子节点内容，索引类型分主键索引和非主键索引</p>
</li>
<li><p>主键索引叶子节点存放的是整行的数据，也成为聚簇索引。</p>
</li>
<li><p>非主键索引叶子节点存放的是主键的值，非主键索引也成为二级索引</p>
</li>
<li><p>区别：基于非主键索引的查询需要多扫描一颗索引树。</p>
</li>
</ul>
<h1 id="索引维护"><a href="#索引维护" class="headerlink" title="索引维护"></a>索引维护</h1><ul>
<li>一个数据页满了，按照B+Tree算法，会新增加一个数据页，这个过程称为页分裂，会导致性能下降，空间利用率降低大概一半。</li>
<li>两个相邻的数据页利用率如果都很低，会做数据合并，也就是页分裂逆过程</li>
<li>B+树的插入可能会引起数据页的分裂，删除可能会引起数据页的合并，二者都是比较重的IO消耗，所以比较好的方式是顺序插入数据，这也是我们一般使用自增主键的原因之一</li>
<li>在Key-Value的场景下，只有一个索引且是唯一索引，则适合直接使用业务字段作为主键索引</li>
<li>非主键索引的叶子结点存储的是主键的值，所以主键字段占用空间不宜过大。同时，其查找数据的过程称为“回表”，需要先查找自己得到主键值，再在主键索引上边查找数据内容。</li>
<li>索引的实现由存储引擎来决定，InnoDB使用B+树（N叉树，比如1200叉树），把整颗树的高度维持在很小的范围内，同时在内存里缓存前面若干层的节点，可以极大地降低访问磁盘的次数，提高读的效率。</li>
</ul>
<h1 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h1><ul>
<li>回到主键索引树搜索的过程，我们称为回表</li>
<li>由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。</li>
</ul>
<h1 id="最左前缀原则"><a href="#最左前缀原则" class="headerlink" title="最左前缀原则"></a>最左前缀原则</h1><ul>
<li>B+ 树这种索引结构，可以利用索引的“最左前缀”，来定位记录。</li>
<li>在建立联合索引的时候，如何安排索引内的字段顺序</li>
<li>第一原则，如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是最需要有限考虑的。</li>
<li>再次考虑空间</li>
</ul>
<h1 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h1><ul>
<li>MySQL 5.6 引入的索引下推优化，可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。</li>
</ul>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><ul>
<li>满足语句需求的情况下， 尽量少地访问资源是数据库设计的重要原则之一。</li>
<li>设计表结构时，也要以减少资源消耗作为目标。</li>
</ul>
<hr>
<ul>
<li>源：&lt;极客时间&gt; MySQL实战45讲教程</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://eviltuzki.top/2019/05/06/MySQL%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93(2)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Eviltuzki">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eviltuzki">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/05/06/MySQL%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93(2)/" class="post-title-link" itemprop="url">MySQL学习总结(2)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-05-06 00:00:00" itemprop="dateCreated datePublished" datetime="2019-05-06T00:00:00+08:00">2019-05-06</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MySQL/" itemprop="url" rel="index"><span itemprop="name">MySQL</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h2><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ul>
<li>脏读</li>
<li>可重复读</li>
<li>幻读</li>
</ul>
<h2 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h2><ul>
<li>读未提交</li>
<li>一个事务还没提交的时候，其所作的变更可以被其他事务看到。</li>
<li>读提交</li>
<li>一个事务提交后，他做的变更才会被其他事务看到。</li>
<li>可重复读</li>
<li>一个事务执行的过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。</li>
<li>串行化</li>
<li>对于同一行记录，写会加写锁，读会加读锁，一旦出现读写锁冲突的时候，后访问的事务必须等前一个事务完成才能继续执行。</li>
</ul>
<h2 id="隔离级别实现"><a href="#隔离级别实现" class="headerlink" title="隔离级别实现"></a>隔离级别实现</h2><ul>
<li>数据库里面会创建一个视图，访问的时候以这个视图的逻辑结果为准。</li>
<li>可重复读，视图在事务启动时创建，这个事务存在期间都在用这个视图。</li>
<li>读提交，视图实在每个sql语句开始执行的时候创建</li>
<li>读未提交，直接返回记录最新值，没有视图概念</li>
<li>串行化，直接用加锁的方式避免并行访问</li>
<li>隔离的实现</li>
<li>每条记录在更新的时候都会同事记录一条回滚操作。记录上的最新值，通过回滚操作都可以得到前一个状态的值。</li>
<li>系统会在没有实物需要使用到这些回滚日志的时候，删除回滚日志。</li>
<li>不要使用长事务</li>
<li>长事务意味着系统里面会存在很老的事务视图。由于这些事务随时可能访问数据库里面的任何数据，所以这个事务提交之前，数据库里面会存储他可能用到的所有回滚记录，导致占用大量的存储空</li>
</ul>
<hr>
<ul>
<li>源：&lt;极客时间&gt; MySQL实战45讲教程</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://eviltuzki.top/2019/05/05/MySQL%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93(1)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Eviltuzki">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eviltuzki">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/05/05/MySQL%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93(1)/" class="post-title-link" itemprop="url">MySQL学习总结(1)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-05-05 00:00:00" itemprop="dateCreated datePublished" datetime="2019-05-05T00:00:00+08:00">2019-05-05</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MySQL/" itemprop="url" rel="index"><span itemprop="name">MySQL</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="SQL执行过程"><a href="#SQL执行过程" class="headerlink" title="SQL执行过程"></a>SQL执行过程</h1><ul>
<li>客户端 -&gt; 连接器 -&gt; 分析器 -&gt; 优化器 -&gt; 执行器</li>
<li>连接器</li>
<li>管理连接，权限验证，维持管理连接</li>
<li>分析器</li>
<li>词法分析，语法分析</li>
<li>优化器</li>
<li>执行计划生成，索引选择</li>
<li>执行器</li>
<li>操作引擎，返回结果</li>
<li>存储引擎</li>
<li>存储数据，提供读写接口</li>
<li>连接器会优先查询缓存，如果命中则直接返回结果</li>
</ul>
<h3 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h3><ul>
<li>连接器负责跟客户端建立连接、获取权限、维持和管理连接。</li>
</ul>
<h3 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h3><ul>
<li>大多数情况下不要使用查询缓存</li>
<li>查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空。</li>
</ul>
<h3 id="分析器"><a href="#分析器" class="headerlink" title="分析器"></a>分析器</h3><ul>
<li>分析器先会做“词法分析”。</li>
</ul>
<h3 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h3><ul>
<li>优化器是在表里面有多个索引的时候，决定使用哪个索引</li>
<li>在一个语句有多表关联（join）的时候，决定各个表的连接顺序。</li>
</ul>
<h3 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h3><ul>
<li>执行之前会进行权限校验</li>
<li>根据表的引擎定义，使用引擎提供的接口</li>
<li>获取记录集作为结果返回给客户端。</li>
</ul>
<h1 id="MySQL日志模块"><a href="#MySQL日志模块" class="headerlink" title="MySQL日志模块"></a>MySQL日志模块</h1><h3 id="redo-log-（重做日志）"><a href="#redo-log-（重做日志）" class="headerlink" title="redo log （重做日志）"></a>redo log （重做日志）</h3><ul>
<li>WAL （Write-Ahead Logging）</li>
<li>核心先写日志，在写磁盘</li>
<li>保证及时数据库发生异常重启，之前提交的记录不会丢失（crash-safe）</li>
<li>InnoDB特有</li>
</ul>
<h3 id="binlog-（归档日志）"><a href="#binlog-（归档日志）" class="headerlink" title="binlog （归档日志）"></a>binlog （归档日志）</h3><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><ul>
<li>redo log 是 InnoDB 引擎特有的；binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用。</li>
<li>redo log 是物理日志，记录的是“在某个数据页上做了什么修改”；binlog 是逻辑日志，记录的是这个语句的原始逻辑，比如“给 ID&#x3D;2 这一行的 c 字段加 1 ”。</li>
<li>redo log 是循环写的，空间固定会用完；binlog 是可以追加写入的。“追加写”是指 binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。</li>
</ul>
<h3 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h3><ul>
<li>引擎讲更新操作记录到redo log中，此时redo log处于prepare状态，同时告知执行器执行完成，可以提交事务。</li>
<li>执行器生成该操作的binlog并写入磁盘。</li>
<li>执行器调用引擎提交事务接口，引擎讲刚刚写入的redo log改为提交commit状态。</li>
<li>redo log的写入拆成了2个步骤prepare和commit，即两阶段提交。</li>
</ul>
<h4 id="先写rodo-log-后写binlog问题"><a href="#先写rodo-log-后写binlog问题" class="headerlink" title="先写rodo log 后写binlog问题"></a>先写rodo log 后写binlog问题</h4><ul>
<li>写完rodo log 后，binlog未写完，重启后，主库可以通过redo log恢复，但是通过binlog恢复临时库会丢失该次更新。</li>
</ul>
<h4 id="先写binlog-后写redo-log问题"><a href="#先写binlog-后写redo-log问题" class="headerlink" title="先写binlog 后写redo log问题"></a>先写binlog 后写redo log问题</h4><ul>
<li>写完binlog后未写redo log，重启后由于redo log没写，即该次事务无效，而binlog中已经包含，则用binlog恢复会多出来一个事务。</li>
</ul>
<hr>
<ul>
<li>源：&lt;极客时间&gt; MySQL实战45讲教程</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://eviltuzki.top/2018/12/20/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%BA%BF%E4%B8%8AES%20Down%E6%9C%BA%E4%BA%8B%E6%95%85/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Eviltuzki">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eviltuzki">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/12/20/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%BA%BF%E4%B8%8AES%20Down%E6%9C%BA%E4%BA%8B%E6%95%85/" class="post-title-link" itemprop="url">记一次线上ES Down机事故</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-12-20 00:00:00" itemprop="dateCreated datePublished" datetime="2018-12-20T00:00:00+08:00">2018-12-20</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ElasticSearch/" itemprop="url" rel="index"><span itemprop="name">ElasticSearch</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>背景</strong></p>
<ul>
<li>前两天的某个上午，正在开会ing。。突然收到了报警Es服务不可用，同时几个其他业务部门的人也都过来反馈说ES挂了。</li>
<li>二话不说先启动ES恢复业务再说。然后就开始分析日志找问题了。</li>
</ul>
<p><strong>排查过程</strong></p>
<ul>
<li>先是怀疑系统资源被用满了，看了一下zabbix，系统负载不太高，8C 16G机器load维持在5-10左右波动，应该不是这个问题。</li>
<li>看了一下网络读取带宽，也没有达到什么高峰(时间是上午10点半左右)，感觉系统方面应该不至于出问题。</li>
<li>又怀疑是出现OOM内存不足，可是也没发现dump文件，然后就开始找ES日志看问题了</li>
<li>看ES日志在down机之前有一个java.lang.StackOverflowError，应该就是这个原因了，之前还真没碰到过这个问题，将错误信息在google上面一查，有一些说是使用前缀或者正则查询导致的，感觉应该是这个问题，便开始抓取down机前1分钟的日志。</li>
<li>运气不坏，很快就找到了一个高度怀疑的参数，是在搜索建议词中出现的，搜索建议词使用的es原生suggest + prefix，传过来的关键词是一个json数组去除了双引号和冒号(应该是api做的过滤)，但是里面还有1600+字符，同时包含了“{}[]”符号，在测试机上面进行一下测试，把这个Query放进去，ES果然直接Down掉了，问题排查就算是完成了。</li>
</ul>
<p><strong>修复过程</strong></p>
<ul>
<li>紧急发布了Hotfix（就是加入参数长度限制，特殊字符限制）</li>
<li>后续准备考虑使用Ngram来解决这个问题</li>
<li>吸取教训：<ul>
<li>能不用就尽可能不用通配符查询，无论是前缀还是模糊</li>
<li>大不了空间换时间，暴力使用ngram解决问题</li>
<li>参数一定要加入校验机制</li>
</ul>
</li>
</ul>
<p><strong>原因分析(转)</strong></p>
<ul>
<li><p>问题出现时，ES服务端日志有如下报错:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">java.lang.StackOverflowError: null</span><br><span class="line">        at org.apache.lucene.util.automaton.Operations.isFinite(Operations.java:1053) ~[lucene-core-6.2.1.jar:6.2.1 43ab70147eb494324a1410f7a9f16a896a59bc6f - shalin - 2016-09-15 05:15:20]</span><br><span class="line">        at org.apache.lucene.util.automaton.Operations.isFinite(Operations.java:1053) ~[lucene-core-6.2.1.jar:6.2.1 43ab70147eb494324a1410f7a9f16a896a59bc6f - shalin - 2016-09-15 05:15:20]</span><br><span class="line">        at org.apache.lucene.util.automaton.Operations.isFinite(Operations.java:1053) ~[lucene-core-6.2.1.jar:6.2.1 43ab70147eb494324a1410f7a9f16a896a59bc6f - shalin - 2016-09-15 05:15:20]</span><br><span class="line">        at org.apache.lucene.util.automaton.Operations.isFinite(Operations.java:1053) ~[lucene-core-6.2.1.jar:6.2.1 43ab70147eb494324a1410f7a9f16a896a59bc6f - shalin - 2016-09-15 05:15:20]</span><br></pre></td></tr></table></figure>
</li>
<li><p>Prefix&#x2F;Regex&#x2F;Fuzzy一类的Query，是直接构造的deterministic automaton，如果查询字符串过长，或者pattern本身过于复杂，构造出来的状态过多，之后一个isFinite的Lucene方法调用可能产生堆栈溢出。</p>
</li>
<li><p>PrefixQuery继承自Lucene的AutomatonQuery，在实例化的时候，maxDeterminizedStates传的是Integer.MAX_VALUE, 并且生成automaton之前，prefix的长度也没有做限制。</p>
</li>
<li><p>附参考链接：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://elasticsearch.cn/article/186">https://elasticsearch.cn/article/186</a></li>
<li><a target="_blank" rel="noopener" href="https://elasticsearch.cn/article/171">https://elasticsearch.cn/article/171</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/elastic/elasticsearch/issues/24553">https://github.com/elastic/elasticsearch/issues/24553</a></li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Eviltuzki</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">57</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">71</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/eviltuzki" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;eviltuzki" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Eviltuzki</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
